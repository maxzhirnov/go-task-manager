
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>api: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/maxzhirnov/go-task-manager/cmd/api/main.go (0.0%)</option>
				
				<option value="file1">github.com/maxzhirnov/go-task-manager/collect_source.go (0.0%)</option>
				
				<option value="file2">github.com/maxzhirnov/go-task-manager/config/config.go (0.0%)</option>
				
				<option value="file3">github.com/maxzhirnov/go-task-manager/docs/docs.go (0.0%)</option>
				
				<option value="file4">github.com/maxzhirnov/go-task-manager/internal/handlers/auth_handler.go (69.5%)</option>
				
				<option value="file5">github.com/maxzhirnov/go-task-manager/internal/handlers/task_handler.go (65.6%)</option>
				
				<option value="file6">github.com/maxzhirnov/go-task-manager/internal/handlers/utils.go (100.0%)</option>
				
				<option value="file7">github.com/maxzhirnov/go-task-manager/internal/middleware/jwt.go (90.0%)</option>
				
				<option value="file8">github.com/maxzhirnov/go-task-manager/internal/models/task.go (97.1%)</option>
				
				<option value="file9">github.com/maxzhirnov/go-task-manager/internal/models/user.go (69.2%)</option>
				
				<option value="file10">github.com/maxzhirnov/go-task-manager/pkg/database/database.go (0.0%)</option>
				
				<option value="file11">github.com/maxzhirnov/go-task-manager/pkg/email/email.go (0.0%)</option>
				
				<option value="file12">github.com/maxzhirnov/go-task-manager/pkg/email/mock_email.go (20.0%)</option>
				
				<option value="file13">github.com/maxzhirnov/go-task-manager/pkg/email/templates.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// @title Task Manager API
// @version 1.0
// @description Task management system with JWT authentication
// @host localhost:8080
// @BasePath /api
// @securityDefinitions.apikey BearerAuth
// @in header
// @name Authorization
package main

import (
        "log"
        "net/http"

        "github.com/gorilla/mux"
        "github.com/maxzhirnov/go-task-manager/config"
        _ "github.com/maxzhirnov/go-task-manager/docs"
        "github.com/maxzhirnov/go-task-manager/internal/handlers"
        "github.com/maxzhirnov/go-task-manager/internal/middleware"
        "github.com/maxzhirnov/go-task-manager/pkg/database"
        "github.com/maxzhirnov/go-task-manager/pkg/email"
        httpSwagger "github.com/swaggo/http-swagger"
)

func setupRouter(cfg *config.Config) *mux.Router <span class="cov0" title="0">{
        db, err := database.InitDB()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to initialize database: %v", err)
        }</span>

        // Initialize email service
        <span class="cov0" title="0">emailService, err := email.NewEmailService(
                cfg.SMTP.Host,
                cfg.SMTP.Port,
                cfg.SMTP.Username,
                cfg.SMTP.Password,
                cfg.SMTP.BaseURL,
        )
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to initialize email service: %v", err)
        }</span>

        <span class="cov0" title="0">r := mux.NewRouter()

        // Auth handlers
        authHandler := handlers.NewAuthHandler(db, emailService)
        r.HandleFunc("/api/register", authHandler.RegisterHandler).Methods("POST")
        r.HandleFunc("/api/login", authHandler.LoginHandler).Methods("POST")
        r.HandleFunc("/api/refresh", authHandler.RefreshTokenHandler).Methods("POST")
        r.HandleFunc("/api/verify-email", authHandler.VerifyEmailHandler).Methods("GET")
        r.HandleFunc("/api/resend-verification", authHandler.ResendVerificationHandler).Methods("POST")

        // Task handlers
        taskHandler := handlers.NewTaskHandler(db)
        api := r.PathPrefix("/api").Subrouter()
        api.Use(middleware.JWTAuthMiddleware)
        api.HandleFunc("/tasks", taskHandler.GetTasks).Methods("GET")
        api.HandleFunc("/tasks", taskHandler.CreateTask).Methods("POST")
        api.HandleFunc("/tasks/{id}", taskHandler.GetTask).Methods("GET")
        api.HandleFunc("/tasks/positions", taskHandler.UpdateTaskPositions).Methods("PUT")
        api.HandleFunc("/tasks/{id}", taskHandler.UpdateTask).Methods("PUT")
        api.HandleFunc("/tasks/{id}", taskHandler.DeleteTask).Methods("DELETE")

        api.HandleFunc("/users/statistics", taskHandler.GetUserStatistics).Methods("GET")

        // Swagger documentation
        r.PathPrefix("/swagger/").Handler(httpSwagger.Handler(
                httpSwagger.URL("/swagger/doc.json"),
                httpSwagger.DeepLinking(true),
        ))

        // Static files for Svelte assets (CSS, JS)
        r.PathPrefix("/_app/").Handler(http.FileServer(http.Dir("./frontend/build")))
        r.PathPrefix("/assets/").Handler(http.FileServer(http.Dir("./frontend/build")))

        // SPA fallback - must be last
        r.PathPrefix("/").HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                http.ServeFile(w, r, "./frontend/build/index.html")
        }</span>)

        <span class="cov0" title="0">return r</span>
}

func main() <span class="cov0" title="0">{
        // Load configuration
        cfg, err := config.LoadConfig()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to load configuration: %v", err)
        }</span>

        <span class="cov0" title="0">r := setupRouter(cfg)

        serverAddr := ":" + cfg.Server.Port
        log.Printf("Server starting on port %s", cfg.Server.Port)
        log.Fatal(http.ListenAndServe(serverAddr, r))</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "fmt"
        "os"
        "path/filepath"
        "strings"
        "time"
)

const (
        outputFile   = "project_source.txt"
        thisFileName = "collect_source.go"
)

var (
        // Конфигурация расширений файлов для парсинга
        fileExtensions = []string{
                ".go",
                // ".html",
                ".sql",
                // ".svelte",
                // ".js",
                // Можно добавить другие расширения
        }

        // Директории для исключения
        excludedDirs = []string{
                ".git",
                "vendor",
                "node_modules",
                "dist",
                "build",
                "coverage",
                ".next",
        }
)

// Helper function to check if directory should be excluded
func shouldExcludeDir(name string) bool <span class="cov0" title="0">{
        for _, dir := range excludedDirs </span><span class="cov0" title="0">{
                if name == dir </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func main() <span class="cov0" title="0">{
        f, err := os.Create(outputFile)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error creating file: %v\n", err)
                return
        }</span>
        <span class="cov0" title="0">defer f.Close()

        // Записываем мета-информацию
        fmt.Fprintf(f, "Project Source Code Export\n")
        fmt.Fprintf(f, "Generated: %s\n", time.Now().Format("2006-01-02 15:04:05"))
        fmt.Fprintf(f, "Parsing extensions: %v\n", fileExtensions)
        fmt.Fprintf(f, "Excluded directories: %v\n", excludedDirs)
        fmt.Fprintf(f, "Working Directory: %s\n", getCurrentDir())
        fmt.Fprintf(f, "\n"+strings.Repeat("-", 80)+"\n\n")

        // Выводим дерево проекта
        fmt.Fprintf(f, "Project Tree:\n")
        fmt.Fprintf(f, "=============\n\n")
        printProjectTree(f, ".", 0, make(map[string]bool))
        fmt.Fprintf(f, "\n"+strings.Repeat("-", 80)+"\n\n")

        // Выводим содержимое файлов
        fmt.Fprintf(f, "Source Code:\n")
        fmt.Fprintf(f, "============\n\n")

        err = filepath.Walk(".", func(path string, info os.FileInfo, err error) error </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Check for excluded directories
                <span class="cov0" title="0">for _, dir := range excludedDirs </span><span class="cov0" title="0">{
                        if strings.Contains(path, dir+string(os.PathSeparator)) </span><span class="cov0" title="0">{
                                return filepath.SkipDir
                        }</span>
                }

                // Пропускаем директории
                <span class="cov0" title="0">if info.IsDir() </span><span class="cov0" title="0">{
                        return nil
                }</span>

                // Пропускаем файл самого скрипта
                <span class="cov0" title="0">if strings.HasSuffix(path, thisFileName) </span><span class="cov0" title="0">{
                        return nil
                }</span>

                // Проверяем расширение файла
                <span class="cov0" title="0">ext := filepath.Ext(path)
                shouldParse := false
                for _, allowedExt := range fileExtensions </span><span class="cov0" title="0">{
                        if ext == allowedExt </span><span class="cov0" title="0">{
                                shouldParse = true
                                break</span>
                        }
                }

                <span class="cov0" title="0">if !shouldParse </span><span class="cov0" title="0">{
                        return nil
                }</span>

                // Читаем содержимое файла
                <span class="cov0" title="0">content, err := os.ReadFile(path)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Записываем путь к файлу и его содержимое
                <span class="cov0" title="0">fmt.Fprintf(f, "// File: %s\n", path)
                fmt.Fprintf(f, "// Size: %d bytes\n", info.Size())
                fmt.Fprintf(f, "// Extension: %s\n", ext)
                fmt.Fprintf(f, strings.Repeat("-", 40)+"\n\n")
                fmt.Fprintf(f, "%s\n\n", string(content))
                fmt.Fprintf(f, strings.Repeat("=", 80)+"\n\n")

                return nil</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error walking directory: %v\n", err)
                return
        }</span>

        <span class="cov0" title="0">fmt.Printf("Source code has been exported to %s\n", outputFile)</span>
}

// printProjectTree выводит дерево проекта
func printProjectTree(f *os.File, path string, level int, isLast map[string]bool) <span class="cov0" title="0">{
        files, err := os.ReadDir(path)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">for i, file := range files </span><span class="cov0" title="0">{
                // Skip excluded directories
                if shouldExcludeDir(file.Name()) </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Формируем префикс для текущего уровня
                <span class="cov0" title="0">prefix := ""
                for l := 0; l &lt; level; l++ </span><span class="cov0" title="0">{
                        if isLast[fmt.Sprintf("%d", l)] </span><span class="cov0" title="0">{
                                prefix += "    "
                        }</span> else<span class="cov0" title="0"> {
                                prefix += "│   "
                        }</span>
                }

                <span class="cov0" title="0">isLastItem := i == len(files)-1
                if isLastItem </span><span class="cov0" title="0">{
                        prefix += "└── "
                }</span> else<span class="cov0" title="0"> {
                        prefix += "├── "
                }</span>

                // Записываем текущий файл/директорию
                <span class="cov0" title="0">fullPath := filepath.Join(path, file.Name())
                fmt.Fprintf(f, "%s%s", prefix, file.Name())
                if !file.IsDir() </span><span class="cov0" title="0">{
                        if info, err := file.Info(); err == nil </span><span class="cov0" title="0">{
                                fmt.Fprintf(f, " (%d bytes)", info.Size())
                        }</span>
                }
                <span class="cov0" title="0">fmt.Fprintf(f, "\n")

                // Рекурсивно обрабатываем поддиректории
                if file.IsDir() </span><span class="cov0" title="0">{
                        newIsLast := make(map[string]bool)
                        for k, v := range isLast </span><span class="cov0" title="0">{
                                newIsLast[k] = v
                        }</span>
                        <span class="cov0" title="0">newIsLast[fmt.Sprintf("%d", level)] = isLastItem
                        printProjectTree(f, fullPath, level+1, newIsLast)</span>
                }
        }
}

func getCurrentDir() string <span class="cov0" title="0">{
        dir, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return "unknown"
        }</span>
        <span class="cov0" title="0">return dir</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package config

import (
        "os"
        "strconv"

        "github.com/joho/godotenv"
)

type Config struct {
        Database struct {
                Host     string
                Port     int
                User     string
                Password string
                DBName   string
        }
        SMTP struct {
                Host      string
                Port      int
                Username  string
                Password  string
                FromName  string   // Added for email "From" display name
                BaseURL   string   // Added for email links
                Templates struct { // Added for template configuration
                        Path string
                }
        }
        Server struct {
                Port string
        }
        JWT struct {
                Secret string
        }
}

func LoadConfig() (*Config, error) <span class="cov0" title="0">{
        // Load .env file if it exists
        godotenv.Load()

        config := &amp;Config{}

        // Database configuration
        config.Database.Host = getEnv("DB_HOST", "localhost")
        config.Database.Port = getEnvAsInt("DB_PORT", 5432)
        config.Database.User = getEnv("DB_USER", "postgres")
        config.Database.Password = getEnv("DB_PASSWORD", "")
        config.Database.DBName = getEnv("DB_NAME", "taskmanager")

        // SMTP configuration
        config.SMTP.Host = getEnv("SMTP_HOST", "smtp.gmail.com")
        config.SMTP.Port = getEnvAsInt("SMTP_PORT", 587)
        config.SMTP.Username = getEnv("SMTP_USERNAME", "")
        config.SMTP.Password = getEnv("SMTP_PASSWORD", "")
        config.SMTP.FromName = getEnv("SMTP_FROM_NAME", "Task Manager")
        config.SMTP.BaseURL = getEnv("SMTP_BASE_URL", "http://localhost:8080")
        config.SMTP.Templates.Path = getEnv("SMTP_TEMPLATES_PATH", "templates/email")

        // Server configuration
        config.Server.Port = getEnv("SERVER_PORT", "8080")

        // JWT configuration
        config.JWT.Secret = getEnv("JWT_SECRET", "your-secret-key")

        return config, nil
}</span>

// Helper function to get environment variable with a default value
func getEnv(key, defaultValue string) string <span class="cov0" title="0">{
        value := os.Getenv(key)
        if value == "" </span><span class="cov0" title="0">{
                return defaultValue
        }</span>
        <span class="cov0" title="0">return value</span>
}

// Helper function to get environment variable as integer
func getEnvAsInt(key string, defaultValue int) int <span class="cov0" title="0">{
        value := os.Getenv(key)
        if value == "" </span><span class="cov0" title="0">{
                return defaultValue
        }</span>
        <span class="cov0" title="0">intValue, err := strconv.Atoi(value)
        if err != nil </span><span class="cov0" title="0">{
                return defaultValue
        }</span>
        <span class="cov0" title="0">return intValue</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// Package docs Code generated by swaggo/swag. DO NOT EDIT
package docs

import "github.com/swaggo/swag"

const docTemplate = `{
    "schemes": {{ marshal .Schemes }},
    "swagger": "2.0",
    "info": {
        "description": "{{escape .Description}}",
        "title": "{{.Title}}",
        "contact": {},
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {
        "/login": {
            "post": {
                "description": "Authenticate user and return access and refresh tokens",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "auth"
                ],
                "summary": "Login user",
                "parameters": [
                    {
                        "description": "User credentials",
                        "name": "credentials",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/handlers.LoginRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Returns access_token and refresh_token",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "400": {
                        "description": "Invalid input",
                        "schema": {
                            "$ref": "#/definitions/models.ErrorResponse"
                        }
                    },
                    "401": {
                        "description": "Invalid credentials",
                        "schema": {
                            "$ref": "#/definitions/models.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/models.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/refresh": {
            "post": {
                "description": "Get new access token using refresh token",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "auth"
                ],
                "summary": "Refresh access token",
                "parameters": [
                    {
                        "description": "Refresh token",
                        "name": "refresh_token",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Returns new access_token",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "400": {
                        "description": "Invalid input",
                        "schema": {
                            "$ref": "#/definitions/models.ErrorResponse"
                        }
                    },
                    "401": {
                        "description": "Invalid refresh token",
                        "schema": {
                            "$ref": "#/definitions/models.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/models.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/register": {
            "post": {
                "description": "Register a new user in the system",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "auth"
                ],
                "summary": "Register new user",
                "parameters": [
                    {
                        "description": "User registration details",
                        "name": "user",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/models.User"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "User registered successfully",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "400": {
                        "description": "Invalid input",
                        "schema": {
                            "$ref": "#/definitions/models.ErrorResponse"
                        }
                    },
                    "409": {
                        "description": "Username already exists",
                        "schema": {
                            "$ref": "#/definitions/models.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/models.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/tasks": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "Get all tasks for the authenticated user",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "tasks"
                ],
                "summary": "Get all tasks",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/models.Task"
                            }
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/models.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/models.ErrorResponse"
                        }
                    }
                }
            },
            "post": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "Create a new task for the authenticated user",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "tasks"
                ],
                "summary": "Create a task",
                "parameters": [
                    {
                        "description": "Task object",
                        "name": "task",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/models.Task"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/models.Task"
                        }
                    },
                    "400": {
                        "description": "Invalid input data",
                        "schema": {
                            "$ref": "#/definitions/models.ErrorResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/models.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/models.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/tasks/positions": {
            "put": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "Update the positions of multiple tasks for the authenticated user",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "tasks"
                ],
                "summary": "Update task positions",
                "parameters": [
                    {
                        "description": "Map of task IDs to new positions",
                        "name": "positions",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "integer"
                            }
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Positions updated successfully",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "400": {
                        "description": "Invalid input",
                        "schema": {
                            "$ref": "#/definitions/models.ErrorResponse"
                        }
                    },
                    "404": {
                        "description": "Task not found",
                        "schema": {
                            "$ref": "#/definitions/models.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/models.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/tasks/{id}": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "Get a specific task by ID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "tasks"
                ],
                "summary": "Get a task",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Task ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/models.Task"
                        }
                    },
                    "400": {
                        "description": "Invalid task ID",
                        "schema": {
                            "$ref": "#/definitions/models.ErrorResponse"
                        }
                    },
                    "404": {
                        "description": "Task not found",
                        "schema": {
                            "$ref": "#/definitions/models.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/models.ErrorResponse"
                        }
                    }
                }
            },
            "put": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "Update an existing task",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "tasks"
                ],
                "summary": "Update a task",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Task ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Task object",
                        "name": "task",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/models.Task"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/models.Task"
                        }
                    },
                    "400": {
                        "description": "Invalid input data",
                        "schema": {
                            "$ref": "#/definitions/models.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/models.ErrorResponse"
                        }
                    }
                }
            },
            "delete": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "Delete a task by ID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "tasks"
                ],
                "summary": "Delete a task",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Task ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "204": {
                        "description": "No Content"
                    },
                    "400": {
                        "description": "Invalid task ID",
                        "schema": {
                            "$ref": "#/definitions/models.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/models.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/users/statistics": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "Get statistics for the authenticated user",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "users"
                ],
                "summary": "Get user statistics",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/models.UserStatistics"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/models.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/models.ErrorResponse"
                        }
                    }
                }
            }
        }
    },
    "definitions": {
        "handlers.LoginRequest": {
            "description": "Login request structure",
            "type": "object",
            "properties": {
                "password": {
                    "description": "Password for authentication\n@example \"secretpassword123\"",
                    "type": "string"
                },
                "username": {
                    "description": "Username for authentication\n@example \"john_doe\"",
                    "type": "string"
                }
            }
        },
        "models.ErrorResponse": {
            "description": "Error response structure",
            "type": "object",
            "properties": {
                "error": {
                    "description": "The error message\n@example \"Invalid input data\"",
                    "type": "string"
                }
            }
        },
        "models.Task": {
            "type": "object",
            "properties": {
                "created_at": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "id": {
                    "type": "integer"
                },
                "position": {
                    "type": "integer"
                },
                "status": {
                    "type": "string"
                },
                "title": {
                    "type": "string"
                },
                "updated_at": {
                    "type": "string"
                },
                "user_id": {
                    "description": "Associate task with a user",
                    "type": "integer"
                }
            }
        },
        "models.User": {
            "type": "object",
            "properties": {
                "created_at": {
                    "type": "string"
                },
                "id": {
                    "type": "integer"
                },
                "password": {
                    "type": "string"
                },
                "updated_at": {
                    "type": "string"
                },
                "username": {
                    "type": "string"
                }
            }
        },
        "models.UserStatistics": {
            "type": "object",
            "properties": {
                "completed_tasks": {
                    "type": "integer"
                },
                "deleted_tasks": {
                    "type": "integer"
                },
                "in_progress_tasks": {
                    "type": "integer"
                },
                "pending_tasks": {
                    "type": "integer"
                },
                "tasks_created_today": {
                    "type": "integer"
                },
                "total_tasks": {
                    "type": "integer"
                },
                "user_id": {
                    "type": "integer"
                },
                "username": {
                    "type": "string"
                }
            }
        }
    },
    "securityDefinitions": {
        "BearerAuth": {
            "type": "apiKey",
            "name": "Authorization",
            "in": "header"
        }
    }
}`

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = &amp;swag.Spec{
        Version:          "1.0",
        Host:             "localhost:8080",
        BasePath:         "/api",
        Schemes:          []string{},
        Title:            "Task Manager API",
        Description:      "Task management system with JWT authentication",
        InfoInstanceName: "swagger",
        SwaggerTemplate:  docTemplate,
        LeftDelim:        "{{",
        RightDelim:       "}}",
}

func init() <span class="cov0" title="0">{
        swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">// @title Task Manager API
// @version 1.0
// @description Task management system with JWT authentication
// @host localhost:8080
// @BasePath /api
// @securityDefinitions.apikey BearerAuth
// @in header
// @name Authorization
package handlers

import (
        "database/sql"
        "encoding/json"
        "log"
        "net/http"
        "strings"

        "github.com/maxzhirnov/go-task-manager/internal/middleware"
        "github.com/maxzhirnov/go-task-manager/internal/models"
        "github.com/maxzhirnov/go-task-manager/pkg/database"
        "github.com/maxzhirnov/go-task-manager/pkg/email"
)

type AuthHandler struct {
        DB                   database.DB
        EmailService         email.EmailSender
        GenerateJWT          func(userID int, username string) (string, error)
        GenerateRefreshToken func(userID int, username string) (string, error)
        ValidateRefreshToken func(token string) (*middleware.Claims, error)
}

func NewAuthHandler(db database.DB, emailService email.EmailSender) *AuthHandler <span class="cov0" title="0">{
        return &amp;AuthHandler{
                DB:                   db,
                EmailService:         emailService,
                GenerateJWT:          middleware.GenerateJWT,
                GenerateRefreshToken: middleware.GenerateRefreshToken,
                ValidateRefreshToken: middleware.ValidateRefreshToken,
        }
}</span>

type RegisterRequest struct {
        Email    string `json:"email"`
        Password string `json:"password"`
}

// @Summary Register new user
// @Description Register a new user in the system
// @Tags auth
// @Accept json
// @Produce json
// @Param user body models.User true "User registration details"
// @Success 201 {object} map[string]string "User registered successfully"
// @Failure 400 {object} models.ErrorResponse "Invalid input"
// @Failure 409 {object} models.ErrorResponse "Username already exists"
// @Failure 500 {object} models.ErrorResponse "Internal server error"
// @Router /register [post]
func (h *AuthHandler) RegisterHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        var req RegisterRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov8" title="1">{
                JSONError(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        // Validate email and password
        <span class="cov8" title="1">if req.Email == "" || req.Password == "" </span><span class="cov8" title="1">{
                JSONError(w, "Email and password are required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">user := &amp;models.User{
                Email:    req.Email,
                Password: req.Password,
        }

        if err := user.HashPassword(); err != nil </span><span class="cov0" title="0">{
                JSONError(w, "Error hashing password", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">if err := user.CreateUser(h.DB); err != nil </span><span class="cov8" title="1">{
                if strings.Contains(err.Error(), "email already exists") </span><span class="cov8" title="1">{
                        JSONError(w, "Email already exists", http.StatusConflict)
                        return
                }</span>
                <span class="cov8" title="1">JSONError(w, "Error creating user", http.StatusInternalServerError)
                return</span>
        }

        <span class="cov8" title="1">token, err := models.GetVerificationTokenForUser(h.DB, user.ID)
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("Failed to get verification token: %v", err)
        }</span> else<span class="cov0" title="0"> {
                if err := h.EmailService.SendVerificationEmail(user.Email, user.Username, token); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to send verification email: %v", err)
                }</span>
        }

        <span class="cov8" title="1">log.Printf("User registered successfully")
        w.WriteHeader(http.StatusCreated)
        json.NewEncoder(w).Encode(map[string]string{
                "message": "User registered successfully",
        })</span>
}

// LoginRequest represents the login request payload
// @Description Login request structure
type LoginRequest struct {
        Email    string `json:"email"`
        Password string `json:"password"`
}

// @Summary Login user
// @Description Authenticate user and return access and refresh tokens
// @Tags auth
// @Accept json
// @Produce json
// @Param credentials body LoginRequest true "User credentials"
// @Success 200 {object} map[string]string "Returns access_token and refresh_token"
// @Failure 400 {object} models.ErrorResponse "Invalid input"
// @Failure 401 {object} models.ErrorResponse "Invalid credentials"
// @Failure 500 {object} models.ErrorResponse "Internal server error"
// @Router /login [post]
func (h *AuthHandler) LoginHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        var req LoginRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov8" title="1">{
                JSONError(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        // Check if email or password is empty
        <span class="cov8" title="1">if req.Email == "" || req.Password == "" </span><span class="cov8" title="1">{
                JSONError(w, "Email and password are required", http.StatusBadRequest)
                return
        }</span>

        // Get the user from the database
        <span class="cov8" title="1">user, err := models.GetUserByEmail(h.DB, req.Email)
        if err != nil </span><span class="cov8" title="1">{
                if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                        JSONError(w, "Invalid credentials", http.StatusUnauthorized)
                        return
                }</span>
                <span class="cov8" title="1">JSONError(w, "Server error", http.StatusInternalServerError)
                return</span>
        }

        // Check if email is verified
        <span class="cov8" title="1">if !user.IsVerified </span><span class="cov8" title="1">{
                JSONError(w, "Please verify your email before logging in", http.StatusForbidden)
                return
        }</span>

        // Check the password
        <span class="cov8" title="1">if err := user.CheckPassword(req.Password); err != nil </span><span class="cov8" title="1">{
                JSONError(w, "Invalid credentials", http.StatusUnauthorized)
                return
        }</span>

        // Generate tokens
        <span class="cov8" title="1">accessToken, err := h.GenerateJWT(user.ID, user.Username)
        if err != nil </span><span class="cov0" title="0">{
                JSONError(w, "Failed to generate access token", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">refreshToken, err := h.GenerateRefreshToken(user.ID, user.Username)
        if err != nil </span><span class="cov0" title="0">{
                JSONError(w, "Failed to generate refresh token", http.StatusInternalServerError)
                return
        }</span>

        // Return tokens
        <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]string{
                "access_token":  accessToken,
                "refresh_token": refreshToken,
        })</span>
}

// @Summary Refresh access token
// @Description Get new access token using refresh token
// @Tags auth
// @Accept json
// @Produce json
// @Param refresh_token body map[string]string true "Refresh token"
// @Success 200 {object} map[string]string "Returns new access_token"
// @Failure 400 {object} models.ErrorResponse "Invalid input"
// @Failure 401 {object} models.ErrorResponse "Invalid refresh token"
// @Failure 500 {object} models.ErrorResponse "Internal server error"
// @Router /refresh [post]
func (h *AuthHandler) RefreshTokenHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        var req struct {
                RefreshToken string `json:"refresh_token"`
        }

        // Parse the request body
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov8" title="1">{
                JSONError(w, "Invalid input", http.StatusBadRequest)
                return
        }</span>

        // Validate the refresh token
        <span class="cov8" title="1">claims, err := h.ValidateRefreshToken(req.RefreshToken)
        if err != nil </span><span class="cov8" title="1">{
                JSONError(w, "Invalid refresh token", http.StatusUnauthorized)
                return
        }</span>

        // Generate a new access token
        <span class="cov8" title="1">accessToken, err := h.GenerateJWT(claims.UserID, claims.Username)
        if err != nil </span><span class="cov0" title="0">{
                JSONError(w, "Failed to generate access token", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">log.Printf("New access token: %s", accessToken)
        // Return the new access token
        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]string{"access_token": accessToken})</span>
}

func (h *AuthHandler) VerifyEmailHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        token := r.URL.Query().Get("token")
        if token == "" </span><span class="cov8" title="1">{
                JSONError(w, "Verification token is required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">err := models.VerifyEmail(h.DB, token)
        if err != nil </span><span class="cov8" title="1">{
                if strings.Contains(err.Error(), "invalid or expired") </span><span class="cov8" title="1">{
                        JSONError(w, "Invalid or expired verification token", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov8" title="1">JSONError(w, "Error verifying email", http.StatusInternalServerError)
                return</span>
        }

        <span class="cov8" title="1">w.WriteHeader(http.StatusOK)
        json.NewEncoder(w).Encode(map[string]string{
                "message": "Email verified successfully",
        })</span>
}

// Добавим метод для повторной отправки верификационного письма
func (h *AuthHandler) ResendVerificationHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req struct {
                Email string `json:"email"`
        }
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                JSONError(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">user, err := models.GetUserByEmail(h.DB, req.Email)
        if err != nil </span><span class="cov0" title="0">{
                JSONError(w, "User not found", http.StatusNotFound)
                return
        }</span>

        <span class="cov0" title="0">if user.IsVerified </span><span class="cov0" title="0">{
                JSONError(w, "Email is already verified", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">token, err := models.CreateVerificationToken(h.DB, user.ID)
        if err != nil </span><span class="cov0" title="0">{
                JSONError(w, "Error generating verification token", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">if err := h.EmailService.SendVerificationEmail(user.Email, user.Username, token.Token); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to send verification email: %v", err)
                JSONError(w, "Error sending verification email", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.WriteHeader(http.StatusOK)
        json.NewEncoder(w).Encode(map[string]string{
                "message": "Verification email sent successfully",
        })</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// @title Task Manager API
// @version 1.0
// @description Task management system with JWT authentication
// @host localhost:8080
// @BasePath /api
// @securityDefinitions.apikey BearerAuth
// @in header
// @name Authorization
package handlers

import (
        "database/sql"
        "encoding/json"
        "log"
        "net/http"
        "strconv"

        "github.com/gorilla/mux"
        "github.com/maxzhirnov/go-task-manager/internal/middleware"
        "github.com/maxzhirnov/go-task-manager/internal/models"
        "github.com/maxzhirnov/go-task-manager/pkg/database"
)

type TaskHandler struct {
        DB database.DB
}

func NewTaskHandler(db database.DB) *TaskHandler <span class="cov8" title="1">{
        return &amp;TaskHandler{DB: db}
}</span>

// @Summary Get all tasks
// @Description Get all tasks for the authenticated user
// @Tags tasks
// @Accept json
// @Produce json
// @Security BearerAuth
// @Success 200 {array} models.Task
// @Failure 401 {object} models.ErrorResponse "Unauthorized"
// @Failure 500 {object} models.ErrorResponse "Internal Server Error"
// @Router /tasks [get]
func (h *TaskHandler) GetTasks(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        // Get the user_id from the JWT claims
        claims, ok := r.Context().Value("claims").(*middleware.Claims)
        if !ok </span><span class="cov8" title="1">{
                http.Error(w, `{"error": "Unauthorized"}`, http.StatusUnauthorized)
                return
        }</span>

        <span class="cov8" title="1">tasks, err := models.GetTasks(h.DB, claims.UserID) // Fetch tasks for the specific user
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("Error fetching tasks: %v", err) // Log the error
                http.Error(w, `{"error": "Failed to fetch tasks"}`, http.StatusInternalServerError)
                return
        }</span>

        // If no tasks exist, return an empty array
        <span class="cov8" title="1">if tasks == nil </span><span class="cov8" title="1">{
                tasks = []models.Task{}
        }</span>

        <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(tasks)</span>
}

// @Summary Get a task
// @Description Get a specific task by ID
// @Tags tasks
// @Accept json
// @Produce json
// @Param id path int true "Task ID"
// @Security BearerAuth
// @Success 200 {object} models.Task
// @Failure 400 {object} models.ErrorResponse "Invalid task ID"
// @Failure 404 {object} models.ErrorResponse "Task not found"
// @Failure 500 {object} models.ErrorResponse "Internal Server Error"
// @Router /tasks/{id} [get]
func (h *TaskHandler) GetTask(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        vars := mux.Vars(r)
        id, err := strconv.Atoi(vars["id"])
        if err != nil </span><span class="cov8" title="1">{
                JSONError(w, "Invalid task ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">task, err := models.GetTask(h.DB, id)
        if err != nil </span><span class="cov8" title="1">{
                if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                        JSONError(w, "Task not found", http.StatusNotFound)
                }</span> else<span class="cov8" title="1"> {
                        JSONError(w, err.Error(), http.StatusInternalServerError)
                }</span>
                <span class="cov8" title="1">return</span>
        }

        <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(task)</span>
}

// @Summary Create a task
// @Description Create a new task for the authenticated user
// @Tags tasks
// @Accept json
// @Produce json
// @Param task body models.Task true "Task object"
// @Security BearerAuth
// @Success 201 {object} models.Task
// @Failure 400 {object} models.ErrorResponse "Invalid input data"
// @Failure 401 {object} models.ErrorResponse "Unauthorized"
// @Failure 500 {object} models.ErrorResponse "Internal Server Error"
// @Router /tasks [post]
func (h *TaskHandler) CreateTask(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        log.Printf("Received create task request")

        var task models.Task
        if err := json.NewDecoder(r.Body).Decode(&amp;task); err != nil </span><span class="cov8" title="1">{
                log.Printf("Error decoding task: %v", err)
                http.Error(w, `{"error": "Invalid input data"}`, http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">log.Printf("Decoded task: %+v", task)

        if task.Title == "" </span><span class="cov8" title="1">{
                log.Printf("Task creation failed: empty title")
                http.Error(w, `{"error": "Title is required"}`, http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">if task.Status == "" </span><span class="cov0" title="0">{
                log.Printf("Setting default status 'pending' for task")
                task.Status = "pending"
        }</span>

        // Get the user_id from the JWT claims
        <span class="cov8" title="1">claims, ok := r.Context().Value("claims").(*middleware.Claims)
        if !ok </span><span class="cov8" title="1">{
                log.Printf("Task creation failed: missing or invalid claims in context")
                http.Error(w, `{"error": "Unauthorized"}`, http.StatusUnauthorized)
                return
        }</span>
        <span class="cov8" title="1">task.UserID = claims.UserID
        log.Printf("Associated task with user ID: %d", task.UserID)

        if err := task.CreateTask(h.DB); err != nil </span><span class="cov8" title="1">{
                log.Printf("Error creating task in database: %v", err)
                log.Printf("Failed task details: %+v", task)
                http.Error(w, `{"error": "Failed to create task"}`, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">log.Printf("Successfully created task with ID: %d", task.ID)
        log.Printf("Final task details: %+v", task)

        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusCreated)
        if err := json.NewEncoder(w).Encode(task); err != nil </span><span class="cov0" title="0">{
                log.Printf("Error encoding response: %v", err)
        }</span>
}

// @Summary Update a task
// @Description Update an existing task
// @Tags tasks
// @Accept json
// @Produce json
// @Param id path int true "Task ID"
// @Param task body models.Task true "Task object"
// @Security BearerAuth
// @Success 200 {object} models.Task
// @Failure 400 {object} models.ErrorResponse "Invalid input data"
// @Failure 500 {object} models.ErrorResponse "Internal Server Error"
// @Router /tasks/{id} [put]
func (h *TaskHandler) UpdateTask(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        log.Printf("Received task update request")
        vars := mux.Vars(r)
        id, err := strconv.Atoi(vars["id"])
        if err != nil </span><span class="cov0" title="0">{
                JSONError(w, "Invalid task ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">var task models.Task
        if err := json.NewDecoder(r.Body).Decode(&amp;task); err != nil </span><span class="cov0" title="0">{
                JSONError(w, "Invalid input data", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">task.ID = id // Assign the ID from the request URL

        if err := task.ValidateStatus(); err != nil </span><span class="cov0" title="0">{
                JSONError(w, err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if err := task.UpdateTask(h.DB); err != nil </span><span class="cov0" title="0">{
                JSONError(w, "Failed to update task", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(task)</span>
}

// @Summary Delete a task
// @Description Delete a task by ID
// @Tags tasks
// @Accept json
// @Produce json
// @Param id path int true "Task ID"
// @Security BearerAuth
// @Success 204 "No Content"
// @Failure 400 {object} models.ErrorResponse "Invalid task ID"
// @Failure 500 {object} models.ErrorResponse "Internal Server Error"
// @Router /tasks/{id} [delete]
func (h *TaskHandler) DeleteTask(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        vars := mux.Vars(r)
        id, err := strconv.Atoi(vars["id"])
        if err != nil </span><span class="cov8" title="1">{
                JSONError(w, "Invalid task ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">if err := models.DeleteTask(h.DB, id); err != nil </span><span class="cov8" title="1">{
                JSONError(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">w.WriteHeader(http.StatusNoContent)</span>
}

// @Summary Update task positions
// @Description Update the positions of multiple tasks for the authenticated user
// @Tags tasks
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param positions body map[int]int true "Map of task IDs to new positions"
// @Success 200 {object} map[string]string "Positions updated successfully"
// @Failure 400 {object} models.ErrorResponse "Invalid input"
// @Failure 404 {object} models.ErrorResponse "Task not found"
// @Failure 500 {object} models.ErrorResponse "Internal Server Error"
// @Router /tasks/positions [put]
func (h *TaskHandler) UpdateTaskPositions(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        log.Printf("Received positions update request")

        claims := r.Context().Value("claims").(*middleware.Claims)
        userID := claims.UserID

        var positions map[int]int
        if err := json.NewDecoder(r.Body).Decode(&amp;positions); err != nil </span><span class="cov8" title="1">{
                log.Printf("Error decoding positions: %v", err)
                JSONError(w, "Invalid input", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">log.Printf("Parsed positions map: %+v", positions)

        for taskID, newPosition := range positions </span><span class="cov8" title="1">{
                // Get the task first
                task, err := models.GetTask(h.DB, taskID)
                if err != nil </span><span class="cov8" title="1">{
                        log.Printf("Task not found: %v", err)
                        JSONError(w, "Task not found", http.StatusNotFound)
                        return
                }</span>

                // Update the task's position
                <span class="cov0" title="0">if err := task.UpdateTaskPosition(h.DB, userID, newPosition); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to update position: %v", err)
                        JSONError(w, "Failed to update position", http.StatusInternalServerError)
                        return
                }</span>
        }

        <span class="cov0" title="0">log.Printf("Positions updated successfully")
        w.WriteHeader(http.StatusOK)
        json.NewEncoder(w).Encode(map[string]string{"message": "Positions updated successfully"})</span>
}

// @Summary Get user statistics
// @Description Get statistics for the authenticated user
// @Tags users
// @Accept json
// @Produce json
// @Security BearerAuth
// @Success 200 {object} models.UserStatistics
// @Failure 401 {object} models.ErrorResponse "Unauthorized"
// @Failure 500 {object} models.ErrorResponse "Internal Server Error"
// @Router /users/statistics [get]
func (h *TaskHandler) GetUserStatistics(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // Get the user_id from the JWT claims
        claims, ok := r.Context().Value("claims").(*middleware.Claims)
        if !ok </span><span class="cov0" title="0">{
                log.Printf("Unauthorized")
                JSONError(w, "Unauthorized", http.StatusUnauthorized)
                return
        }</span>

        // Get statistics for the user
        <span class="cov0" title="0">stats, err := models.GetUserStatistics(h.DB, claims.UserID)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error fetching user statistics: %v", err)
                JSONError(w, "Failed to fetch user statistics", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">log.Printf("User statistics: %v", stats)
        // Return the statistics
        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(stats)</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package handlers

import (
        "encoding/json"
        "log"
        "net/http"
)

// JSONError sends a JSON-formatted error response
func JSONError(w http.ResponseWriter, message string, status int) <span class="cov8" title="1">{
        log.Printf("Error: %s", message)
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(status)
        json.NewEncoder(w).Encode(map[string]string{"error": message})
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package middleware

import (
        "context"
        "errors"
        "net/http"
        "os"
        "strings"
        "time"

        "github.com/dgrijalva/jwt-go"
)

var (
        // Load JWT secrets from environment variables with defaults
        jwtSecret        = []byte(getEnvWithDefault("JWT_SECRET", "default_secret_key_please_change_in_production"))
        jwtRefreshSecret = []byte(getEnvWithDefault("JWT_REFRESH_SECRET", "default_refresh_secret_key_please_change_in_production"))
)

// getEnvWithDefault returns environment variable value or default if not set
func getEnvWithDefault(key, defaultValue string) string <span class="cov8" title="1">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                return value
        }</span>
        <span class="cov8" title="1">return defaultValue</span>
}

// Claims represents the JWT claims
type Claims struct {
        UserID   int    `json:"user_id"`
        Username string `json:"username"`
        jwt.StandardClaims
}

// GenerateJWT generates a new JWT token
func GenerateJWT(userID int, username string) (string, error) <span class="cov8" title="1">{
        expirationTime := time.Now().Add(1 * time.Hour) // Access token expires in 1 hour
        claims := &amp;Claims{
                UserID:   userID,
                Username: username,
                StandardClaims: jwt.StandardClaims{
                        ExpiresAt: expirationTime.Unix(),
                },
        }
        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        return token.SignedString(jwtSecret)
}</span>

// GenerateRefreshToken generates a new refresh token
func GenerateRefreshToken(userID int, username string) (string, error) <span class="cov8" title="1">{
        expirationTime := time.Now().Add(7 * 24 * time.Hour) // Refresh token expires in 7 days
        claims := &amp;Claims{
                UserID:   userID,
                Username: username,
                StandardClaims: jwt.StandardClaims{
                        ExpiresAt: expirationTime.Unix(),
                },
        }
        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        return token.SignedString(jwtRefreshSecret)
}</span>

// ValidateJWT validates a JWT token and returns the claims
func ValidateJWT(tokenString string) (*Claims, error) <span class="cov8" title="1">{
        token, err := jwt.ParseWithClaims(tokenString, &amp;Claims{}, func(token *jwt.Token) (interface{}, error) </span><span class="cov8" title="1">{
                return jwtSecret, nil
        }</span>)

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">claims, ok := token.Claims.(*Claims)
        if !ok || !token.Valid </span><span class="cov0" title="0">{
                return nil, errors.New("invalid token")
        }</span>

        <span class="cov8" title="1">return claims, nil</span>
}

// ValidateRefreshToken validates a refresh token

func ValidateRefreshToken(tokenString string) (*Claims, error) <span class="cov8" title="1">{
        token, err := jwt.ParseWithClaims(tokenString, &amp;Claims{}, func(token *jwt.Token) (interface{}, error) </span><span class="cov8" title="1">{
                return jwtRefreshSecret, nil
        }</span>)
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">claims, ok := token.Claims.(*Claims)
        if !ok || !token.Valid </span><span class="cov0" title="0">{
                return nil, jwt.ErrSignatureInvalid
        }</span>
        <span class="cov8" title="1">return claims, nil</span>
}

// JWTAuthMiddleware is the middleware to protect routes
func JWTAuthMiddleware(next http.Handler) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                authHeader := r.Header.Get("Authorization")
                if authHeader == "" </span><span class="cov8" title="1">{
                        http.Error(w, "Authorization header required", http.StatusUnauthorized)
                        return
                }</span>

                <span class="cov8" title="1">tokenString := strings.TrimPrefix(authHeader, "Bearer ")
                claims, err := ValidateJWT(tokenString)
                if err != nil </span><span class="cov8" title="1">{
                        http.Error(w, "Invalid token", http.StatusUnauthorized)
                        return
                }</span>

                // Add claims to the context
                <span class="cov8" title="1">ctx := context.WithValue(r.Context(), "claims", claims)
                r = r.WithContext(ctx)

                next.ServeHTTP(w, r)</span>
        })
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package models

import (
        "fmt"
        "log"
        "time"

        "github.com/maxzhirnov/go-task-manager/pkg/database"
)

const (
        StatusPending    = "pending"
        StatusInProgress = "in_progress"
        StatusCompleted  = "completed"
        StatusDeleted    = "deleted"
)

var ValidStatuses = []string{StatusPending, StatusInProgress, StatusCompleted}

type Task struct {
        ID          int       `json:"id"`
        Title       string    `json:"title"`
        Description string    `json:"description"`
        Status      string    `json:"status"`
        UserID      int       `json:"user_id"` // Associate task with a user
        CreatedAt   time.Time `json:"created_at"`
        UpdatedAt   time.Time `json:"updated_at"`
        Position    int       `json:"position"`
}

func GetTasks(db database.DB, userID int) ([]Task, error) <span class="cov8" title="1">{
        query := `SELECT id, title, description, status, user_id, position, created_at, updated_at 
              FROM tasks 
              WHERE user_id = $1 
                          AND status != 'deleted'
              ORDER BY position ASC`
        rows, err := db.Query(query, userID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var tasks []Task
        for rows.Next() </span><span class="cov8" title="1">{
                var t Task
                err := rows.Scan(&amp;t.ID, &amp;t.Title, &amp;t.Description, &amp;t.Status,
                        &amp;t.UserID, &amp;t.Position, &amp;t.CreatedAt, &amp;t.UpdatedAt)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">tasks = append(tasks, t)</span>
        }
        <span class="cov8" title="1">return tasks, nil</span>
}

func GetTask(db database.DB, id int) (Task, error) <span class="cov8" title="1">{
        var t Task
        query := `SELECT id, title, description, status, user_id, position, created_at, updated_at 
              FROM tasks 
              WHERE id = $1`
        err := db.QueryRow(query, id).Scan(&amp;t.ID, &amp;t.Title, &amp;t.Description, &amp;t.Status,
                &amp;t.UserID, &amp;t.Position, &amp;t.CreatedAt, &amp;t.UpdatedAt)
        return t, err
}</span>

func (t *Task) CreateTask(db database.DB) error <span class="cov8" title="1">{
        // Start a transaction
        tx, err := db.Begin()
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">defer tx.Rollback()

        // Increment positions of existing tasks
        _, err = tx.Exec(`
        UPDATE tasks 
        SET position = position + 1
        WHERE user_id = $1`, t.UserID)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Set the position of the new task to 0
        <span class="cov8" title="1">t.Position = 0

        // Insert the new task
        query := `
        INSERT INTO tasks (title, description, status, user_id, position, created_at, updated_at)
        VALUES ($1, $2, $3, $4, $5, $6, $7)
        RETURNING id`

        t.CreatedAt = time.Now()
        t.UpdatedAt = time.Now()

        err = tx.QueryRow(query, t.Title, t.Description, t.Status, t.UserID, t.Position, t.CreatedAt, t.UpdatedAt).Scan(&amp;t.ID)
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("Error inserting task into database: %v", err)
                return err
        }</span>

        <span class="cov8" title="1">return tx.Commit()</span>
}

func (t *Task) UpdateTask(db database.DB) error <span class="cov8" title="1">{
        query := `
                UPDATE tasks
                SET title = $1, description = $2, status = $3, updated_at = $4
                WHERE id = $5`

        t.UpdatedAt = time.Now()

        _, err := db.Exec(query, t.Title, t.Description, t.Status, t.UpdatedAt, t.ID)
        return err
}</span>

func (t *Task) UpdateTaskPosition(db database.DB, userID int, newPosition int) error <span class="cov8" title="1">{
        tx, err := db.Begin()
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">defer tx.Rollback()

        // Get current position
        var oldPosition int
        err = tx.QueryRow(`
        SELECT position 
        FROM tasks 
        WHERE id = $1 AND user_id = $2`, t.ID, userID).Scan(&amp;oldPosition)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Update positions of other tasks
        <span class="cov8" title="1">if oldPosition &lt; newPosition </span><span class="cov8" title="1">{
                _, err = tx.Exec(`
            UPDATE tasks 
            SET position = position - 1,
                updated_at = $1
            WHERE user_id = $2 
            AND position &gt; $3 
            AND position &lt;= $4`,
                        time.Now(), userID, oldPosition, newPosition)
        }</span> else<span class="cov8" title="1"> {
                _, err = tx.Exec(`
            UPDATE tasks 
            SET position = position + 1,
                updated_at = $1
            WHERE user_id = $2 
            AND position &gt;= $3 
            AND position &lt; $4`,
                        time.Now(), userID, newPosition, oldPosition)
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Update position of the current task
        <span class="cov8" title="1">t.Position = newPosition
        t.UpdatedAt = time.Now()
        _, err = tx.Exec(`
        UPDATE tasks 
        SET position = $1,
            updated_at = $2
        WHERE id = $3 AND user_id = $4`,
                t.Position, t.UpdatedAt, t.ID, userID)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return tx.Commit()</span>
}

func (t *Task) ValidateStatus() error <span class="cov8" title="1">{
        for _, status := range ValidStatuses </span><span class="cov8" title="1">{
                if t.Status == status </span><span class="cov8" title="1">{
                        return nil
                }</span>
        }
        <span class="cov8" title="1">return fmt.Errorf("invalid status: %s", t.Status)</span>
}

func DeleteTask(db database.DB, id int) error <span class="cov8" title="1">{
        query := `
        UPDATE tasks 
        SET status = 'deleted', updated_at = $1 
        WHERE id = $2
    `
        result, err := db.Exec(query, time.Now(), id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if rowsAffected == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("task not found")
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package models

import (
        "crypto/rand"
        "database/sql"
        "encoding/hex"
        "fmt"
        "log"
        "strings"
        "time"

        "github.com/lib/pq"
        "github.com/maxzhirnov/go-task-manager/pkg/database"
        "golang.org/x/crypto/bcrypt"
)

type User struct {
        ID         int       `json:"id"`
        Username   string    `json:"username"`
        Email      string    `json:"email"`
        Password   string    `json:"password,omitempty"`
        IsVerified bool      `json:"is_verified"`
        CreatedAt  time.Time `json:"created_at"`
        UpdatedAt  time.Time `json:"updated_at"`
}

type VerificationToken struct {
        ID        int        `json:"id"`
        UserID    int        `json:"user_id"`
        Token     string     `json:"token"`
        ExpiresAt time.Time  `json:"expires_at"`
        CreatedAt time.Time  `json:"created_at"`
        UsedAt    *time.Time `json:"used_at,omitempty"`
}

type UserStatistics struct {
        UserID            int    `json:"user_id"`
        Username          string `json:"username"`
        TotalTasks        int    `json:"total_tasks"`
        CompletedTasks    int    `json:"completed_tasks"`
        PendingTasks      int    `json:"pending_tasks"`
        InProgressTasks   int    `json:"in_progress_tasks"`
        DeletedTasks      int    `json:"deleted_tasks"`
        TasksCreatedToday int    `json:"tasks_created_today"`
}

// GenerateVerificationToken generates a random verification token
func GenerateVerificationToken() (string, error) <span class="cov8" title="1">{
        bytes := make([]byte, 32)
        if _, err := rand.Read(bytes); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">return hex.EncodeToString(bytes), nil</span>
}

// CreateVerificationToken creates a verification token for a user
// Not using for now
func CreateVerificationToken(db database.DB, userID int) (*VerificationToken, error) <span class="cov8" title="1">{
        token, err := GenerateVerificationToken()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">vt := &amp;VerificationToken{
                UserID:    userID,
                Token:     token,
                ExpiresAt: time.Now().Add(24 * time.Hour),
                CreatedAt: time.Now(),
        }

        query := `
        INSERT INTO verification_tokens (user_id, token, expires_at, created_at)
        VALUES ($1, $2, $3, $4)
        RETURNING id`

        err = db.QueryRow(query, vt.UserID, vt.Token, vt.ExpiresAt, vt.CreatedAt).Scan(&amp;vt.ID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return vt, nil</span>
}

func GetVerificationTokenForUser(db database.DB, userID int) (string, error) <span class="cov8" title="1">{
        var token string
        query := `
        SELECT token 
        FROM verification_tokens 
        WHERE user_id = $1 
        AND used_at IS NULL 
        AND expires_at &gt; NOW() 
        ORDER BY created_at DESC 
        LIMIT 1`

        err := db.QueryRow(query, userID).Scan(&amp;token)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>
        <span class="cov8" title="1">return token, nil</span>
}

func VerifyEmail(db database.DB, token string) error <span class="cov8" title="1">{
        tx, err := db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer tx.Rollback()

        var userID int
        query := `
        UPDATE verification_tokens 
        SET used_at = NOW()
        WHERE token = $1 
        AND expires_at &gt; NOW() 
        AND used_at IS NULL
        RETURNING user_id`

        err = tx.QueryRow(query, token).Scan(&amp;userID)
        if err != nil </span><span class="cov8" title="1">{
                if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                        return fmt.Errorf("invalid or expired verification token")
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        // Обновляем статус верификации пользователя
        <span class="cov8" title="1">_, err = tx.Exec(`UPDATE users SET is_verified = true WHERE id = $1`, userID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return tx.Commit()</span>
}

// HashPassword hashes the user's password
func (u *User) HashPassword() error <span class="cov8" title="1">{
        hashedPassword, err := bcrypt.GenerateFromPassword([]byte(u.Password), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">u.Password = string(hashedPassword) // Replace plaintext password with hash
        return nil</span>
}

// CheckPassword compares a plaintext password with the hashed password
func (u *User) CheckPassword(password string) error <span class="cov0" title="0">{
        log.Printf("Attempting to compare:")
        log.Printf("Stored hash: %s", u.Password)
        log.Printf("Input password: %s", password)

        if password == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("password cannot be empty")
        }</span>

        <span class="cov0" title="0">err := bcrypt.CompareHashAndPassword([]byte(u.Password), []byte(password))
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Password comparison failed: %v", err)
        }</span>
        <span class="cov0" title="0">return err</span>
}

// CreateUser inserts a new user into the database
func (u *User) CreateUser(db database.DB) error <span class="cov8" title="1">{
        if u.Email == "" || u.Password == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("email and password are required")
        }</span>

        <span class="cov8" title="1">if u.Username == "" </span><span class="cov8" title="1">{
                u.Username = strings.Split(u.Email, "@")[0]
        }</span>

        <span class="cov8" title="1">if !strings.HasPrefix(u.Password, "$2a$") </span><span class="cov8" title="1">{
                return fmt.Errorf("password must be hashed before saving")
        }</span>

        <span class="cov8" title="1">tx, err := db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer tx.Rollback()

        // Создаем пользователя
        query := `
        INSERT INTO users (email, username, password, is_verified, created_at, updated_at)
        VALUES ($1, $2, $3, $4, $5, $6)
        RETURNING id`

        u.CreatedAt = time.Now()
        u.UpdatedAt = time.Now()
        u.IsVerified = false

        err = tx.QueryRow(query, u.Email, u.Username, u.Password, u.IsVerified,
                u.CreatedAt, u.UpdatedAt).Scan(&amp;u.ID)
        if err != nil </span><span class="cov0" title="0">{
                if pqErr, ok := err.(*pq.Error); ok &amp;&amp; pqErr.Code == "23505" </span><span class="cov0" title="0">{
                        if strings.Contains(pqErr.Message, "email") </span><span class="cov0" title="0">{
                                return fmt.Errorf("email already exists")
                        }</span>
                        <span class="cov0" title="0">return fmt.Errorf("username already exists")</span>
                }
                <span class="cov0" title="0">return err</span>
        }

        // Создаем токен верификации
        <span class="cov8" title="1">token, err := GenerateVerificationToken()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">verificationQuery := `
        INSERT INTO verification_tokens (user_id, token, expires_at, created_at)
        VALUES ($1, $2, $3, $4)`

        _, err = tx.Exec(verificationQuery,
                u.ID,
                token,
                time.Now().Add(24*time.Hour),
                time.Now(),
        )
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return tx.Commit()</span>
}

func ResendVerificationToken(db database.DB, userID int) (*VerificationToken, error) <span class="cov8" title="1">{
        // Проверяем, не верифицирован ли уже пользователь
        var isVerified bool
        err := db.QueryRow(`SELECT is_verified FROM users WHERE id = $1`, userID).Scan(&amp;isVerified)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if isVerified </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("user is already verified")
        }</span>

        // Деактивируем старые токены
        <span class="cov8" title="1">_, err = db.Exec(`
        UPDATE verification_tokens 
        SET used_at = NOW() 
        WHERE user_id = $1 AND used_at IS NULL`,
                userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Создаем новый токен
        <span class="cov8" title="1">return CreateVerificationToken(db, userID)</span>
}

// Add new method for finding user by email
func GetUserByEmail(db database.DB, email string) (User, error) <span class="cov8" title="1">{
        var user User
        query := `SELECT id, email, username, password, is_verified, created_at, updated_at 
              FROM users 
              WHERE email = $1`
        err := db.QueryRow(query, email).Scan(
                &amp;user.ID,
                &amp;user.Email,
                &amp;user.Username,
                &amp;user.Password,
                &amp;user.IsVerified,
                &amp;user.CreatedAt,
                &amp;user.UpdatedAt,
        )
        if err != nil </span><span class="cov8" title="1">{
                return user, err
        }</span>
        <span class="cov8" title="1">return user, nil</span>
}

// GetUserByUsername retrieves a user by their username
func GetUserByUsername(db database.DB, username string) (User, error) <span class="cov0" title="0">{
        var user User
        query := `SELECT id, username, password, created_at, updated_at FROM users WHERE username = $1`
        err := db.QueryRow(query, username).Scan(&amp;user.ID, &amp;user.Username, &amp;user.Password, &amp;user.CreatedAt, &amp;user.UpdatedAt)
        if err != nil </span><span class="cov0" title="0">{
                return user, err
        }</span>
        <span class="cov0" title="0">if user.Password == "" </span><span class="cov0" title="0">{
                return user, fmt.Errorf("invalid password hash")
        }</span>
        <span class="cov0" title="0">return user, nil</span>
}

func GetUserStatistics(db database.DB, userID int) (*UserStatistics, error) <span class="cov8" title="1">{
        stats := &amp;UserStatistics{}
        query := `
        SELECT 
            user_id, username, total_tasks, completed_tasks,
            pending_tasks, in_progress_tasks, deleted_tasks,
            tasks_created_today
        FROM user_statistics
        WHERE user_id = $1`

        err := db.QueryRow(query, userID).Scan(
                &amp;stats.UserID, &amp;stats.Username, &amp;stats.TotalTasks,
                &amp;stats.CompletedTasks, &amp;stats.PendingTasks,
                &amp;stats.InProgressTasks, &amp;stats.DeletedTasks,
                &amp;stats.TasksCreatedToday,
        )
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return stats, nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package database

import (
        "database/sql"
        "fmt"
        "log"
        "time"

        _ "github.com/lib/pq"
        "github.com/maxzhirnov/go-task-manager/config"
)

// DB interface remains the same
type DB interface {
        Query(query string, args ...interface{}) (*sql.Rows, error)
        QueryRow(query string, args ...interface{}) *sql.Row
        Exec(query string, args ...interface{}) (sql.Result, error)
        Close() error
        Begin() (*sql.Tx, error)
}

type DBConfig struct {
        Host     string
        Port     int
        User     string
        Password string
        DBName   string
}

func InitDB() (DB, error) <span class="cov0" title="0">{
        // Load configuration
        cfg, err := config.LoadConfig()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to load config: %v", err)
        }</span>

        <span class="cov0" title="0">dbConfig := DBConfig{
                Host:     cfg.Database.Host,
                Port:     cfg.Database.Port,
                User:     cfg.Database.User,
                Password: cfg.Database.Password,
                DBName:   cfg.Database.DBName,
        }

        return ConnectWithRetry(dbConfig)</span>
}

func ConnectWithRetry(cfg DBConfig) (DB, error) <span class="cov0" title="0">{
        connStr := fmt.Sprintf("host=%s port=%d user=%s password=%s dbname=%s sslmode=disable",
                cfg.Host, cfg.Port, cfg.User, cfg.Password, cfg.DBName)

        // Try to connect to the database with retries
        var db *sql.DB
        var err error
        maxRetries := 5

        for i := 0; i &lt; maxRetries; i++ </span><span class="cov0" title="0">{
                db, err = sql.Open("postgres", connStr)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to open database connection: %v", err)
                        time.Sleep(time.Second * 5)
                        continue</span>
                }

                <span class="cov0" title="0">err = db.Ping()
                if err == nil </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">log.Printf("Failed to ping database (attempt %d/%d): %v", i+1, maxRetries, err)
                time.Sleep(time.Second * 5)</span>
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to connect to database after %d attempts: %v", maxRetries, err)
        }</span>

        // Set connection pool settings
        <span class="cov0" title="0">db.SetMaxOpenConns(25)
        db.SetMaxIdleConns(25)
        db.SetConnMaxLifetime(5 * time.Minute)

        return db, nil</span>
}

// For testing purposes
func InitTestDB(cfg DBConfig) (DB, error) <span class="cov0" title="0">{
        return ConnectWithRetry(cfg)
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package email

import (
        "fmt"
        "time"

        "gopkg.in/mail.v2"
)

type EmailSender interface {
        SendWelcomeEmail(to, username string) error
        SendVerificationEmail(to, username, token string) error
}

type EmailService struct {
        dialer    *mail.Dialer
        from      string
        templates *EmailTemplate
        baseURL   string
}

func NewEmailService(host string, port int, username, password, baseURL string) (*EmailService, error) <span class="cov0" title="0">{
        templates, err := NewEmailTemplate()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;EmailService{
                dialer:    mail.NewDialer(host, port, username, password),
                from:      username,
                templates: templates,
                baseURL:   baseURL,
        }, nil</span>
}

func (s *EmailService) SendWelcomeEmail(to, username string) error <span class="cov0" title="0">{
        data := WelcomeEmailData{
                Username: username,
                LoginURL: s.baseURL + "/login",
                Year:     time.Now().Year(),
        }

        body, err := s.templates.ExecuteTemplate("welcome.html", data)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">m := mail.NewMessage()
        m.SetHeader("From", s.from)
        m.SetHeader("To", to)
        m.SetHeader("Subject", "Welcome to Task Manager!")
        m.SetBody("text/html", body)

        return s.dialer.DialAndSend(m)</span>
}

type VerificationEmailData struct {
        Username         string
        VerificationLink string
        Year             int
}

func (s *EmailService) SendVerificationEmail(to, username, token string) error <span class="cov0" title="0">{
        m := mail.NewMessage()
        m.SetHeader("From", s.from)
        m.SetHeader("To", to)
        m.SetHeader("Subject", "Verify Your Email Address")

        // Prepare template data
        data := VerificationEmailData{
                Username:         username,
                VerificationLink: fmt.Sprintf("%s/verify-email?token=%s", s.baseURL, token),
                Year:             time.Now().Year(),
        }

        // Execute template
        body, err := s.templates.ExecuteTemplate("verification.html", data)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to execute email template: %v", err)
        }</span>

        <span class="cov0" title="0">m.SetBody("text/html", body)
        return s.dialer.DialAndSend(m)</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package email

import "log"

type MockEmailService struct{}

// Ensure MockEmailService implements EmailSender
var _ EmailSender = (*MockEmailService)(nil)

func NewMockEmailService() EmailSender <span class="cov8" title="1">{
        return &amp;MockEmailService{}
}</span>

func (s *MockEmailService) SendWelcomeEmail(to, username string) error <span class="cov0" title="0">{
        log.Printf("Mock: Sending welcome email to %s (%s)", username, to)
        return nil
}</span>

func (s *MockEmailService) SendVerificationEmail(to, username, token string) error <span class="cov0" title="0">{
        log.Printf("Mock: Sending verification email to %s (%s)", username, to)
        return nil
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package email

import (
        "bytes"
        "html/template"
)

type EmailTemplate struct {
        templates *template.Template
}

type WelcomeEmailData struct {
        Username string
        LoginURL string
        Year     int
}

func NewEmailTemplate() (*EmailTemplate, error) <span class="cov0" title="0">{
        // Загружаем все шаблоны из директории templates/email
        templates, err := template.ParseGlob("templates/email/*.html")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;EmailTemplate{templates: templates}, nil</span>
}

func (et *EmailTemplate) ExecuteTemplate(name string, data interface{}) (string, error) <span class="cov0" title="0">{
        var buf bytes.Buffer
        if err := et.templates.ExecuteTemplate(&amp;buf, name, data); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return buf.String(), nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
