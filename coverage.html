
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>api: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/maxzhirnov/go-task-manager/cmd/api/main.go (0.0%)</option>
				
				<option value="file1">github.com/maxzhirnov/go-task-manager/collect_source.go (0.0%)</option>
				
				<option value="file2">github.com/maxzhirnov/go-task-manager/docs/docs.go (0.0%)</option>
				
				<option value="file3">github.com/maxzhirnov/go-task-manager/internal/handlers/auth_handler.go (63.6%)</option>
				
				<option value="file4">github.com/maxzhirnov/go-task-manager/internal/handlers/task_handler.go (97.9%)</option>
				
				<option value="file5">github.com/maxzhirnov/go-task-manager/internal/handlers/utils.go (100.0%)</option>
				
				<option value="file6">github.com/maxzhirnov/go-task-manager/internal/middleware/jwt.go (90.0%)</option>
				
				<option value="file7">github.com/maxzhirnov/go-task-manager/internal/models/task.go (91.9%)</option>
				
				<option value="file8">github.com/maxzhirnov/go-task-manager/internal/models/user.go (86.5%)</option>
				
				<option value="file9">github.com/maxzhirnov/go-task-manager/pkg/database/database.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// @title Task Manager API
// @version 1.0
// @description Task management system with JWT authentication
// @host localhost:8080
// @BasePath /api
// @securityDefinitions.apikey BearerAuth
// @in header
// @name Authorization
package main

import (
        "log"
        "net/http"
        "os"

        "github.com/gorilla/mux"
        _ "github.com/maxzhirnov/go-task-manager/docs"
        "github.com/maxzhirnov/go-task-manager/internal/handlers"
        "github.com/maxzhirnov/go-task-manager/internal/middleware"
        "github.com/maxzhirnov/go-task-manager/pkg/database"
        httpSwagger "github.com/swaggo/http-swagger"
)

func setupRouter() *mux.Router <span class="cov0" title="0">{
        db, err := database.InitDB()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to initialize database: %v", err)
        }</span>

        <span class="cov0" title="0">r := mux.NewRouter()

        // Auth handlers
        authHandler := handlers.NewAuthHandler(db)
        r.HandleFunc("/api/register", authHandler.RegisterHandler).Methods("POST")
        r.HandleFunc("/api/login", authHandler.LoginHandler).Methods("POST")
        r.HandleFunc("/api/refresh", authHandler.RefreshTokenHandler).Methods("POST")

        // Task handlers
        taskHandler := handlers.NewTaskHandler(db)
        api := r.PathPrefix("/api").Subrouter()
        api.Use(middleware.JWTAuthMiddleware)
        api.HandleFunc("/tasks", taskHandler.GetTasks).Methods("GET")
        api.HandleFunc("/tasks", taskHandler.CreateTask).Methods("POST")
        api.HandleFunc("/tasks/{id}", taskHandler.GetTask).Methods("GET")
        api.HandleFunc("/tasks/positions", taskHandler.UpdateTaskPositions).Methods("PUT")
        api.HandleFunc("/tasks/{id}", taskHandler.UpdateTask).Methods("PUT")
        api.HandleFunc("/tasks/{id}", taskHandler.DeleteTask).Methods("DELETE")

        // Swagger documentation
        r.PathPrefix("/swagger/").Handler(httpSwagger.Handler(
                httpSwagger.URL("/swagger/doc.json"),
                httpSwagger.DeepLinking(true),
        ))

        // r.PathPrefix("/").Handler(http.FileServer(http.Dir("./web")))

        // Static files for Svelte assets (CSS, JS)
        r.PathPrefix("/_app/").Handler(http.FileServer(http.Dir("./frontend/build")))
        r.PathPrefix("/assets/").Handler(http.FileServer(http.Dir("./frontend/build")))

        // SPA fallback - must be last
        r.PathPrefix("/").HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                http.ServeFile(w, r, "./frontend/build/index.html")
        }</span>)

        <span class="cov0" title="0">return r</span>
}

func main() <span class="cov0" title="0">{
        r := setupRouter()

        port := os.Getenv("PORT")
        if port == "" </span><span class="cov0" title="0">{
                port = "8080"
        }</span>
        <span class="cov0" title="0">log.Printf("Server starting on port %s", port)
        log.Fatal(http.ListenAndServe(":"+port, r))</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "fmt"
        "os"
        "path/filepath"
        "strings"
        "time"
)

const (
        outputFile   = "project_source.txt"
        thisFileName = "collect_source.go"
)

// Конфигурация расширений файлов для парсинга
var fileExtensions = []string{
        ".go",
        ".html",
        ".sql",
        ".svelte",
        ".js",
        // Можно добавить другие расширения
}

func main() <span class="cov0" title="0">{
        f, err := os.Create(outputFile)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error creating file: %v\n", err)
                return
        }</span>
        <span class="cov0" title="0">defer f.Close()

        // Записываем мета-информацию
        fmt.Fprintf(f, "Project Source Code Export\n")
        fmt.Fprintf(f, "Generated: %s\n", time.Now().Format("2006-01-02 15:04:05"))
        fmt.Fprintf(f, "Parsing extensions: %v\n", fileExtensions)
        fmt.Fprintf(f, "Working Directory: %s\n", getCurrentDir())
        fmt.Fprintf(f, "\n"+strings.Repeat("-", 80)+"\n\n")

        // Выводим дерево проекта
        fmt.Fprintf(f, "Project Tree:\n")
        fmt.Fprintf(f, "=============\n\n")
        printProjectTree(f, ".", 0, make(map[string]bool))
        fmt.Fprintf(f, "\n"+strings.Repeat("-", 80)+"\n\n")

        // Выводим содержимое файлов
        fmt.Fprintf(f, "Source Code:\n")
        fmt.Fprintf(f, "============\n\n")

        err = filepath.Walk(".", func(path string, info os.FileInfo, err error) error </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Пропускаем директории
                <span class="cov0" title="0">if info.IsDir() </span><span class="cov0" title="0">{
                        return nil
                }</span>

                // Пропускаем файл самого скрипта
                <span class="cov0" title="0">if strings.HasSuffix(path, thisFileName) </span><span class="cov0" title="0">{
                        return nil
                }</span>

                // Пропускаем файлы в .git и vendor директориях
                <span class="cov0" title="0">if strings.Contains(path, ".git/") || strings.Contains(path, "vendor/") </span><span class="cov0" title="0">{
                        return nil
                }</span>

                // Проверяем расширение файла
                <span class="cov0" title="0">ext := filepath.Ext(path)
                shouldParse := false
                for _, allowedExt := range fileExtensions </span><span class="cov0" title="0">{
                        if ext == allowedExt </span><span class="cov0" title="0">{
                                shouldParse = true
                                break</span>
                        }
                }

                <span class="cov0" title="0">if !shouldParse </span><span class="cov0" title="0">{
                        return nil
                }</span>

                // Читаем содержимое файла
                <span class="cov0" title="0">content, err := os.ReadFile(path)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Записываем путь к файлу и его содержимое
                <span class="cov0" title="0">fmt.Fprintf(f, "// File: %s\n", path)
                fmt.Fprintf(f, "// Size: %d bytes\n", info.Size())
                fmt.Fprintf(f, "// Extension: %s\n", ext)
                fmt.Fprintf(f, strings.Repeat("-", 40)+"\n\n")
                fmt.Fprintf(f, "%s\n\n", string(content))
                fmt.Fprintf(f, strings.Repeat("=", 80)+"\n\n")

                return nil</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error walking directory: %v\n", err)
                return
        }</span>

        <span class="cov0" title="0">fmt.Printf("Source code has been exported to %s\n", outputFile)</span>
}

// printProjectTree выводит дерево проекта
func printProjectTree(f *os.File, path string, level int, isLast map[string]bool) <span class="cov0" title="0">{
        files, err := os.ReadDir(path)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">for i, file := range files </span><span class="cov0" title="0">{
                // Пропускаем .git и vendor директории
                if file.Name() == ".git" || file.Name() == "vendor" </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Формируем префикс для текущего уровня
                <span class="cov0" title="0">prefix := ""
                for l := 0; l &lt; level; l++ </span><span class="cov0" title="0">{
                        if isLast[fmt.Sprintf("%d", l)] </span><span class="cov0" title="0">{
                                prefix += "    "
                        }</span> else<span class="cov0" title="0"> {
                                prefix += "│   "
                        }</span>
                }

                <span class="cov0" title="0">isLastItem := i == len(files)-1
                if isLastItem </span><span class="cov0" title="0">{
                        prefix += "└── "
                }</span> else<span class="cov0" title="0"> {
                        prefix += "├── "
                }</span>

                // Записываем текущий файл/директорию
                <span class="cov0" title="0">fullPath := filepath.Join(path, file.Name())
                fmt.Fprintf(f, "%s%s", prefix, file.Name())
                if !file.IsDir() </span><span class="cov0" title="0">{
                        if info, err := file.Info(); err == nil </span><span class="cov0" title="0">{
                                fmt.Fprintf(f, " (%d bytes)", info.Size())
                        }</span>
                }
                <span class="cov0" title="0">fmt.Fprintf(f, "\n")

                // Рекурсивно обрабатываем поддиректории
                if file.IsDir() </span><span class="cov0" title="0">{
                        newIsLast := make(map[string]bool)
                        for k, v := range isLast </span><span class="cov0" title="0">{
                                newIsLast[k] = v
                        }</span>
                        <span class="cov0" title="0">newIsLast[fmt.Sprintf("%d", level)] = isLastItem
                        printProjectTree(f, fullPath, level+1, newIsLast)</span>
                }
        }
}

func getCurrentDir() string <span class="cov0" title="0">{
        dir, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return "unknown"
        }</span>
        <span class="cov0" title="0">return dir</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// Package docs Code generated by swaggo/swag. DO NOT EDIT
package docs

import "github.com/swaggo/swag"

const docTemplate = `{
    "schemes": {{ marshal .Schemes }},
    "swagger": "2.0",
    "info": {
        "description": "{{escape .Description}}",
        "title": "{{.Title}}",
        "contact": {},
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {
        "/login": {
            "post": {
                "description": "Authenticate user and return access and refresh tokens",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "auth"
                ],
                "summary": "Login user",
                "parameters": [
                    {
                        "description": "User credentials",
                        "name": "credentials",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/handlers.LoginRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Returns access_token and refresh_token",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "400": {
                        "description": "Invalid input",
                        "schema": {
                            "$ref": "#/definitions/models.ErrorResponse"
                        }
                    },
                    "401": {
                        "description": "Invalid credentials",
                        "schema": {
                            "$ref": "#/definitions/models.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/models.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/refresh": {
            "post": {
                "description": "Get new access token using refresh token",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "auth"
                ],
                "summary": "Refresh access token",
                "parameters": [
                    {
                        "description": "Refresh token",
                        "name": "refresh_token",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Returns new access_token",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "400": {
                        "description": "Invalid input",
                        "schema": {
                            "$ref": "#/definitions/models.ErrorResponse"
                        }
                    },
                    "401": {
                        "description": "Invalid refresh token",
                        "schema": {
                            "$ref": "#/definitions/models.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/models.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/register": {
            "post": {
                "description": "Register a new user in the system",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "auth"
                ],
                "summary": "Register new user",
                "parameters": [
                    {
                        "description": "User registration details",
                        "name": "user",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/models.User"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "User registered successfully",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "400": {
                        "description": "Invalid input",
                        "schema": {
                            "$ref": "#/definitions/models.ErrorResponse"
                        }
                    },
                    "409": {
                        "description": "Username already exists",
                        "schema": {
                            "$ref": "#/definitions/models.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/models.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/tasks": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "Get all tasks for the authenticated user",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "tasks"
                ],
                "summary": "Get all tasks",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/models.Task"
                            }
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/models.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/models.ErrorResponse"
                        }
                    }
                }
            },
            "post": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "Create a new task for the authenticated user",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "tasks"
                ],
                "summary": "Create a task",
                "parameters": [
                    {
                        "description": "Task object",
                        "name": "task",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/models.Task"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/models.Task"
                        }
                    },
                    "400": {
                        "description": "Invalid input data",
                        "schema": {
                            "$ref": "#/definitions/models.ErrorResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/models.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/models.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/tasks/positions": {
            "put": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "Update the positions of multiple tasks for the authenticated user",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "tasks"
                ],
                "summary": "Update task positions",
                "parameters": [
                    {
                        "description": "Map of task IDs to new positions",
                        "name": "positions",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "integer"
                            }
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Positions updated successfully",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "400": {
                        "description": "Invalid input",
                        "schema": {
                            "$ref": "#/definitions/models.ErrorResponse"
                        }
                    },
                    "404": {
                        "description": "Task not found",
                        "schema": {
                            "$ref": "#/definitions/models.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/models.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/tasks/{id}": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "Get a specific task by ID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "tasks"
                ],
                "summary": "Get a task",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Task ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/models.Task"
                        }
                    },
                    "400": {
                        "description": "Invalid task ID",
                        "schema": {
                            "$ref": "#/definitions/models.ErrorResponse"
                        }
                    },
                    "404": {
                        "description": "Task not found",
                        "schema": {
                            "$ref": "#/definitions/models.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/models.ErrorResponse"
                        }
                    }
                }
            },
            "put": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "Update an existing task",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "tasks"
                ],
                "summary": "Update a task",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Task ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Task object",
                        "name": "task",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/models.Task"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/models.Task"
                        }
                    },
                    "400": {
                        "description": "Invalid input data",
                        "schema": {
                            "$ref": "#/definitions/models.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/models.ErrorResponse"
                        }
                    }
                }
            },
            "delete": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "Delete a task by ID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "tasks"
                ],
                "summary": "Delete a task",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Task ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "204": {
                        "description": "No Content"
                    },
                    "400": {
                        "description": "Invalid task ID",
                        "schema": {
                            "$ref": "#/definitions/models.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/models.ErrorResponse"
                        }
                    }
                }
            }
        }
    },
    "definitions": {
        "handlers.LoginRequest": {
            "description": "Login request structure",
            "type": "object",
            "properties": {
                "password": {
                    "description": "Password for authentication\n@example \"secretpassword123\"",
                    "type": "string"
                },
                "username": {
                    "description": "Username for authentication\n@example \"john_doe\"",
                    "type": "string"
                }
            }
        },
        "models.ErrorResponse": {
            "description": "Error response structure",
            "type": "object",
            "properties": {
                "error": {
                    "description": "The error message\n@example \"Invalid input data\"",
                    "type": "string"
                }
            }
        },
        "models.Task": {
            "type": "object",
            "properties": {
                "created_at": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "id": {
                    "type": "integer"
                },
                "position": {
                    "type": "integer"
                },
                "status": {
                    "type": "string"
                },
                "title": {
                    "type": "string"
                },
                "updated_at": {
                    "type": "string"
                },
                "user_id": {
                    "description": "Associate task with a user",
                    "type": "integer"
                }
            }
        },
        "models.User": {
            "type": "object",
            "properties": {
                "created_at": {
                    "type": "string"
                },
                "id": {
                    "type": "integer"
                },
                "password": {
                    "type": "string"
                },
                "updated_at": {
                    "type": "string"
                },
                "username": {
                    "type": "string"
                }
            }
        }
    },
    "securityDefinitions": {
        "BearerAuth": {
            "type": "apiKey",
            "name": "Authorization",
            "in": "header"
        }
    }
}`

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = &amp;swag.Spec{
        Version:          "1.0",
        Host:             "localhost:8080",
        BasePath:         "/api",
        Schemes:          []string{},
        Title:            "Task Manager API",
        Description:      "Task management system with JWT authentication",
        InfoInstanceName: "swagger",
        SwaggerTemplate:  docTemplate,
        LeftDelim:        "{{",
        RightDelim:       "}}",
}

func init() <span class="cov0" title="0">{
        swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">// @title Task Manager API
// @version 1.0
// @description Task management system with JWT authentication
// @host localhost:8080
// @BasePath /api
// @securityDefinitions.apikey BearerAuth
// @in header
// @name Authorization
package handlers

import (
        "encoding/json"
        "log"
        "net/http"

        "github.com/maxzhirnov/go-task-manager/internal/middleware"
        "github.com/maxzhirnov/go-task-manager/internal/models"
        "github.com/maxzhirnov/go-task-manager/pkg/database"
)

type AuthHandler struct {
        DB                   database.DB
        GenerateJWT          func(userID int, username string) (string, error)
        GenerateRefreshToken func(userID int, username string) (string, error)
        ValidateRefreshToken func(token string) (*middleware.Claims, error)
}

func NewAuthHandler(db database.DB) *AuthHandler <span class="cov8" title="1">{
        return &amp;AuthHandler{
                DB:                   db,
                GenerateJWT:          middleware.GenerateJWT,
                GenerateRefreshToken: middleware.GenerateRefreshToken,
                ValidateRefreshToken: middleware.ValidateRefreshToken,
        }
}</span>

// @Summary Register new user
// @Description Register a new user in the system
// @Tags auth
// @Accept json
// @Produce json
// @Param user body models.User true "User registration details"
// @Success 201 {object} map[string]string "User registered successfully"
// @Failure 400 {object} models.ErrorResponse "Invalid input"
// @Failure 409 {object} models.ErrorResponse "Username already exists"
// @Failure 500 {object} models.ErrorResponse "Internal server error"
// @Router /register [post]
func (h *AuthHandler) RegisterHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        var user models.User
        if err := json.NewDecoder(r.Body).Decode(&amp;user); err != nil </span><span class="cov0" title="0">{
                log.Printf("Error decoding input: %v", err)
                JSONError(w, "Invalid input", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">log.Printf("Registering user with password: %s", user.Password)

        // Hash the password
        if err := user.HashPassword(); err != nil </span><span class="cov0" title="0">{
                log.Printf("Error hashing password: %v", err)
                JSONError(w, "Failed to hash password", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">log.Printf("Password hashed to: %s", user.Password)

        // Create the user
        if err := user.CreateUser(h.DB); err != nil </span><span class="cov8" title="1">{
                log.Printf("Error creating user: %v", err)

                // Check for duplicate username error
                if err.Error() == "username already exists" </span><span class="cov8" title="1">{
                        log.Printf("Username already exists")
                        JSONError(w, "Username already exists", http.StatusConflict)
                        return
                }</span>

                <span class="cov0" title="0">JSONError(w, "Failed to create user", http.StatusInternalServerError)
                return</span>
        }

        <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusCreated)
        json.NewEncoder(w).Encode(map[string]string{"message": "User registered successfully"})</span>
}

// LoginRequest represents the login request payload
// @Description Login request structure
type LoginRequest struct {
        // Username for authentication
        // @example "john_doe"
        Username string `json:"username"`

        // Password for authentication
        // @example "secretpassword123"
        Password string `json:"password"`
}

// @Summary Login user
// @Description Authenticate user and return access and refresh tokens
// @Tags auth
// @Accept json
// @Produce json
// @Param credentials body LoginRequest true "User credentials"
// @Success 200 {object} map[string]string "Returns access_token and refresh_token"
// @Failure 400 {object} models.ErrorResponse "Invalid input"
// @Failure 401 {object} models.ErrorResponse "Invalid credentials"
// @Failure 500 {object} models.ErrorResponse "Internal server error"
// @Router /login [post]
func (h *AuthHandler) LoginHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        var req LoginRequest

        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to decode login request: %v", err)
                JSONError(w, "Invalid input", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">log.Printf("Login attempt for user: %s with password: %s", req.Username, req.Password)

        // Check if password or username is empty FIRST
        if req.Username == "" || req.Password == "" </span><span class="cov8" title="1">{
                JSONError(w, "Username and password are required", http.StatusBadRequest)
                return
        }</span>

        // Get the user from the database
        <span class="cov8" title="1">user, err := models.GetUserByUsername(h.DB, req.Username)
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("Failed to get user by username: %v", err)
                JSONError(w, "Invalid credentials", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov8" title="1">log.Printf("Retrieved user: %s, stored hash: %s", user.Username, user.Password)

        // Check the password
        if err := user.CheckPassword(req.Password); err != nil </span><span class="cov0" title="0">{
                log.Printf("Password check failed: %v", err)
                JSONError(w, "Invalid credentials", http.StatusUnauthorized)
                return
        }</span>

        // Generate the access token
        <span class="cov8" title="1">accessToken, err := h.GenerateJWT(user.ID, user.Username)
        if err != nil </span><span class="cov0" title="0">{
                JSONError(w, "Failed to generate access token", http.StatusInternalServerError)
                return
        }</span>

        // Generate the refresh token
        <span class="cov8" title="1">refreshToken, err := h.GenerateRefreshToken(user.ID, user.Username)
        if err != nil </span><span class="cov0" title="0">{
                JSONError(w, "Failed to generate refresh token", http.StatusInternalServerError)
                return
        }</span>

        // Return both tokens to the client
        <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]string{
                "access_token":  accessToken,
                "refresh_token": refreshToken,
        })</span>
}

// @Summary Refresh access token
// @Description Get new access token using refresh token
// @Tags auth
// @Accept json
// @Produce json
// @Param refresh_token body map[string]string true "Refresh token"
// @Success 200 {object} map[string]string "Returns new access_token"
// @Failure 400 {object} models.ErrorResponse "Invalid input"
// @Failure 401 {object} models.ErrorResponse "Invalid refresh token"
// @Failure 500 {object} models.ErrorResponse "Internal server error"
// @Router /refresh [post]
func (h *AuthHandler) RefreshTokenHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        var req struct {
                RefreshToken string `json:"refresh_token"`
        }

        // Parse the request body
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                JSONError(w, "Invalid input", http.StatusBadRequest)
                return
        }</span>

        // Validate the refresh token
        <span class="cov8" title="1">claims, err := h.ValidateRefreshToken(req.RefreshToken)
        if err != nil </span><span class="cov0" title="0">{
                JSONError(w, "Invalid refresh token", http.StatusUnauthorized)
                return
        }</span>

        // Generate a new access token
        <span class="cov8" title="1">accessToken, err := h.GenerateJWT(claims.UserID, claims.Username)
        if err != nil </span><span class="cov0" title="0">{
                JSONError(w, "Failed to generate access token", http.StatusInternalServerError)
                return
        }</span>

        // Return the new access token
        <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]string{"access_token": accessToken})</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// @title Task Manager API
// @version 1.0
// @description Task management system with JWT authentication
// @host localhost:8080
// @BasePath /api
// @securityDefinitions.apikey BearerAuth
// @in header
// @name Authorization
package handlers

import (
        "database/sql"
        "encoding/json"
        "log"
        "net/http"
        "strconv"

        "github.com/gorilla/mux"
        "github.com/maxzhirnov/go-task-manager/internal/middleware"
        "github.com/maxzhirnov/go-task-manager/internal/models"
        "github.com/maxzhirnov/go-task-manager/pkg/database"
)

type TaskHandler struct {
        DB database.DB
}

func NewTaskHandler(db database.DB) *TaskHandler <span class="cov8" title="1">{
        return &amp;TaskHandler{DB: db}
}</span>

// @Summary Get all tasks
// @Description Get all tasks for the authenticated user
// @Tags tasks
// @Accept json
// @Produce json
// @Security BearerAuth
// @Success 200 {array} models.Task
// @Failure 401 {object} models.ErrorResponse "Unauthorized"
// @Failure 500 {object} models.ErrorResponse "Internal Server Error"
// @Router /tasks [get]
func (h *TaskHandler) GetTasks(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        // Get the user_id from the JWT claims
        claims, ok := r.Context().Value("claims").(*middleware.Claims)
        if !ok </span><span class="cov8" title="1">{
                http.Error(w, `{"error": "Unauthorized"}`, http.StatusUnauthorized)
                return
        }</span>

        <span class="cov8" title="1">tasks, err := models.GetTasks(h.DB, claims.UserID) // Fetch tasks for the specific user
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("Error fetching tasks: %v", err) // Log the error
                http.Error(w, `{"error": "Failed to fetch tasks"}`, http.StatusInternalServerError)
                return
        }</span>

        // If no tasks exist, return an empty array
        <span class="cov8" title="1">if tasks == nil </span><span class="cov8" title="1">{
                tasks = []models.Task{}
        }</span>

        <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(tasks)</span>
}

// @Summary Get a task
// @Description Get a specific task by ID
// @Tags tasks
// @Accept json
// @Produce json
// @Param id path int true "Task ID"
// @Security BearerAuth
// @Success 200 {object} models.Task
// @Failure 400 {object} models.ErrorResponse "Invalid task ID"
// @Failure 404 {object} models.ErrorResponse "Task not found"
// @Failure 500 {object} models.ErrorResponse "Internal Server Error"
// @Router /tasks/{id} [get]
func (h *TaskHandler) GetTask(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        vars := mux.Vars(r)
        id, err := strconv.Atoi(vars["id"])
        if err != nil </span><span class="cov8" title="1">{
                JSONError(w, "Invalid task ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">task, err := models.GetTask(h.DB, id)
        if err != nil </span><span class="cov8" title="1">{
                if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                        JSONError(w, "Task not found", http.StatusNotFound)
                }</span> else<span class="cov8" title="1"> {
                        JSONError(w, err.Error(), http.StatusInternalServerError)
                }</span>
                <span class="cov8" title="1">return</span>
        }

        <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(task)</span>
}

// @Summary Create a task
// @Description Create a new task for the authenticated user
// @Tags tasks
// @Accept json
// @Produce json
// @Param task body models.Task true "Task object"
// @Security BearerAuth
// @Success 201 {object} models.Task
// @Failure 400 {object} models.ErrorResponse "Invalid input data"
// @Failure 401 {object} models.ErrorResponse "Unauthorized"
// @Failure 500 {object} models.ErrorResponse "Internal Server Error"
// @Router /tasks [post]
func (h *TaskHandler) CreateTask(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        var task models.Task
        if err := json.NewDecoder(r.Body).Decode(&amp;task); err != nil </span><span class="cov8" title="1">{
                log.Printf("Error decoding task: %v", err) // Log the error
                http.Error(w, `{"error": "Invalid input data"}`, http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">if task.Title == "" </span><span class="cov8" title="1">{
                http.Error(w, `{"error": "Title is required"}`, http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">if task.Status == "" </span><span class="cov8" title="1">{
                task.Status = "pending"
        }</span>

        // Get the user_id from the JWT claims
        <span class="cov8" title="1">claims, ok := r.Context().Value("claims").(*middleware.Claims)
        if !ok </span><span class="cov8" title="1">{
                http.Error(w, `{"error": "Unauthorized"}`, http.StatusUnauthorized)
                return
        }</span>
        <span class="cov8" title="1">task.UserID = claims.UserID // Associate the task with the user

        if err := task.CreateTask(h.DB); err != nil </span><span class="cov8" title="1">{
                log.Printf("Error creating task: %v", err) // Log the error
                http.Error(w, `{"error": "Failed to create task"}`, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusCreated)
        json.NewEncoder(w).Encode(task)</span>
}

// @Summary Update a task
// @Description Update an existing task
// @Tags tasks
// @Accept json
// @Produce json
// @Param id path int true "Task ID"
// @Param task body models.Task true "Task object"
// @Security BearerAuth
// @Success 200 {object} models.Task
// @Failure 400 {object} models.ErrorResponse "Invalid input data"
// @Failure 500 {object} models.ErrorResponse "Internal Server Error"
// @Router /tasks/{id} [put]
func (h *TaskHandler) UpdateTask(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        log.Printf("Received task update request")
        vars := mux.Vars(r)
        id, err := strconv.Atoi(vars["id"])
        if err != nil </span><span class="cov8" title="1">{
                JSONError(w, "Invalid task ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">var task models.Task
        if err := json.NewDecoder(r.Body).Decode(&amp;task); err != nil </span><span class="cov8" title="1">{
                JSONError(w, "Invalid input data", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">task.ID = id // Assign the ID from the request URL

        if err := task.ValidateStatus(); err != nil </span><span class="cov8" title="1">{
                JSONError(w, err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">if err := task.UpdateTask(h.DB); err != nil </span><span class="cov8" title="1">{
                JSONError(w, "Failed to update task", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(task)</span>
}

// @Summary Delete a task
// @Description Delete a task by ID
// @Tags tasks
// @Accept json
// @Produce json
// @Param id path int true "Task ID"
// @Security BearerAuth
// @Success 204 "No Content"
// @Failure 400 {object} models.ErrorResponse "Invalid task ID"
// @Failure 500 {object} models.ErrorResponse "Internal Server Error"
// @Router /tasks/{id} [delete]
func (h *TaskHandler) DeleteTask(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        vars := mux.Vars(r)
        id, err := strconv.Atoi(vars["id"])
        if err != nil </span><span class="cov8" title="1">{
                JSONError(w, "Invalid task ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">if err := models.DeleteTask(h.DB, id); err != nil </span><span class="cov8" title="1">{
                JSONError(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">w.WriteHeader(http.StatusNoContent)</span>
}

// @Summary Update task positions
// @Description Update the positions of multiple tasks for the authenticated user
// @Tags tasks
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param positions body map[int]int true "Map of task IDs to new positions"
// @Success 200 {object} map[string]string "Positions updated successfully"
// @Failure 400 {object} models.ErrorResponse "Invalid input"
// @Failure 404 {object} models.ErrorResponse "Task not found"
// @Failure 500 {object} models.ErrorResponse "Internal Server Error"
// @Router /tasks/positions [put]
func (h *TaskHandler) UpdateTaskPositions(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        log.Printf("Received positions update request")

        claims := r.Context().Value("claims").(*middleware.Claims)
        userID := claims.UserID

        var positions map[int]int
        if err := json.NewDecoder(r.Body).Decode(&amp;positions); err != nil </span><span class="cov8" title="1">{
                log.Printf("Error decoding positions: %v", err)
                JSONError(w, "Invalid input", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">log.Printf("Parsed positions map: %+v", positions)

        for taskID, newPosition := range positions </span><span class="cov8" title="1">{
                // Get the task first
                task, err := models.GetTask(h.DB, taskID)
                if err != nil </span><span class="cov8" title="1">{
                        JSONError(w, "Task not found", http.StatusNotFound)
                        return
                }</span>

                // Update the task's position
                <span class="cov8" title="1">if err := task.UpdateTaskPosition(h.DB, userID, newPosition); err != nil </span><span class="cov0" title="0">{
                        JSONError(w, "Failed to update position", http.StatusInternalServerError)
                        return
                }</span>
        }

        <span class="cov8" title="1">w.WriteHeader(http.StatusOK)
        json.NewEncoder(w).Encode(map[string]string{"message": "Positions updated successfully"})</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package handlers

import (
        "encoding/json"
        "net/http"
)

// JSONError sends a JSON-formatted error response
func JSONError(w http.ResponseWriter, message string, status int) <span class="cov8" title="1">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(status)
        json.NewEncoder(w).Encode(map[string]string{"error": message})
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package middleware

import (
        "context"
        "errors"
        "net/http"
        "os"
        "strings"
        "time"

        "github.com/dgrijalva/jwt-go"
)

var (
        // Load JWT secrets from environment variables with defaults
        jwtSecret        = []byte(getEnvWithDefault("JWT_SECRET", "default_secret_key_please_change_in_production"))
        jwtRefreshSecret = []byte(getEnvWithDefault("JWT_REFRESH_SECRET", "default_refresh_secret_key_please_change_in_production"))
)

// getEnvWithDefault returns environment variable value or default if not set
func getEnvWithDefault(key, defaultValue string) string <span class="cov8" title="1">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                return value
        }</span>
        <span class="cov8" title="1">return defaultValue</span>
}

// Claims represents the JWT claims
type Claims struct {
        UserID   int    `json:"user_id"`
        Username string `json:"username"`
        jwt.StandardClaims
}

// GenerateJWT generates a new JWT token
func GenerateJWT(userID int, username string) (string, error) <span class="cov8" title="1">{
        expirationTime := time.Now().Add(1 * time.Hour) // Access token expires in 1 hour
        claims := &amp;Claims{
                UserID:   userID,
                Username: username,
                StandardClaims: jwt.StandardClaims{
                        ExpiresAt: expirationTime.Unix(),
                },
        }
        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        return token.SignedString(jwtSecret)
}</span>

// GenerateRefreshToken generates a new refresh token
func GenerateRefreshToken(userID int, username string) (string, error) <span class="cov8" title="1">{
        expirationTime := time.Now().Add(7 * 24 * time.Hour) // Refresh token expires in 7 days
        claims := &amp;Claims{
                UserID:   userID,
                Username: username,
                StandardClaims: jwt.StandardClaims{
                        ExpiresAt: expirationTime.Unix(),
                },
        }
        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        return token.SignedString(jwtRefreshSecret)
}</span>

// ValidateJWT validates a JWT token and returns the claims
func ValidateJWT(tokenString string) (*Claims, error) <span class="cov8" title="1">{
        token, err := jwt.ParseWithClaims(tokenString, &amp;Claims{}, func(token *jwt.Token) (interface{}, error) </span><span class="cov8" title="1">{
                return jwtSecret, nil
        }</span>)

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">claims, ok := token.Claims.(*Claims)
        if !ok || !token.Valid </span><span class="cov0" title="0">{
                return nil, errors.New("invalid token")
        }</span>

        <span class="cov8" title="1">return claims, nil</span>
}

// ValidateRefreshToken validates a refresh token

func ValidateRefreshToken(tokenString string) (*Claims, error) <span class="cov8" title="1">{
        token, err := jwt.ParseWithClaims(tokenString, &amp;Claims{}, func(token *jwt.Token) (interface{}, error) </span><span class="cov8" title="1">{
                return jwtRefreshSecret, nil
        }</span>)
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">claims, ok := token.Claims.(*Claims)
        if !ok || !token.Valid </span><span class="cov0" title="0">{
                return nil, jwt.ErrSignatureInvalid
        }</span>
        <span class="cov8" title="1">return claims, nil</span>
}

// JWTAuthMiddleware is the middleware to protect routes
func JWTAuthMiddleware(next http.Handler) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                authHeader := r.Header.Get("Authorization")
                if authHeader == "" </span><span class="cov8" title="1">{
                        http.Error(w, "Authorization header required", http.StatusUnauthorized)
                        return
                }</span>

                <span class="cov8" title="1">tokenString := strings.TrimPrefix(authHeader, "Bearer ")
                claims, err := ValidateJWT(tokenString)
                if err != nil </span><span class="cov8" title="1">{
                        http.Error(w, "Invalid token", http.StatusUnauthorized)
                        return
                }</span>

                // Add claims to the context
                <span class="cov8" title="1">ctx := context.WithValue(r.Context(), "claims", claims)
                r = r.WithContext(ctx)

                next.ServeHTTP(w, r)</span>
        })
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package models

import (
        "fmt"
        "log"
        "time"

        "github.com/maxzhirnov/go-task-manager/pkg/database"
)

const (
        StatusPending    = "pending"
        StatusInProgress = "in_progress"
        StatusCompleted  = "completed"
)

var ValidStatuses = []string{StatusPending, StatusInProgress, StatusCompleted}

type Task struct {
        ID          int       `json:"id"`
        Title       string    `json:"title"`
        Description string    `json:"description"`
        Status      string    `json:"status"`
        UserID      int       `json:"user_id"` // Associate task with a user
        CreatedAt   time.Time `json:"created_at"`
        UpdatedAt   time.Time `json:"updated_at"`
        Position    int       `json:"position"`
}

func GetTasks(db database.DB, userID int) ([]Task, error) <span class="cov8" title="1">{
        query := `SELECT id, title, description, status, user_id, position, created_at, updated_at 
              FROM tasks 
              WHERE user_id = $1 
              ORDER BY position ASC`
        rows, err := db.Query(query, userID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var tasks []Task
        for rows.Next() </span><span class="cov8" title="1">{
                var t Task
                err := rows.Scan(&amp;t.ID, &amp;t.Title, &amp;t.Description, &amp;t.Status,
                        &amp;t.UserID, &amp;t.Position, &amp;t.CreatedAt, &amp;t.UpdatedAt)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">tasks = append(tasks, t)</span>
        }
        <span class="cov8" title="1">return tasks, nil</span>
}

func GetTask(db database.DB, id int) (Task, error) <span class="cov8" title="1">{
        var t Task
        query := `SELECT id, title, description, status, user_id, position, created_at, updated_at 
              FROM tasks 
              WHERE id = $1`
        err := db.QueryRow(query, id).Scan(&amp;t.ID, &amp;t.Title, &amp;t.Description, &amp;t.Status,
                &amp;t.UserID, &amp;t.Position, &amp;t.CreatedAt, &amp;t.UpdatedAt)
        return t, err
}</span>

func (t *Task) CreateTask(db database.DB) error <span class="cov8" title="1">{
        query := `
        INSERT INTO tasks (title, description, status, user_id, created_at, updated_at)
        VALUES ($1, $2, $3, $4, $5, $6)
        RETURNING id`

        t.CreatedAt = time.Now()
        t.UpdatedAt = time.Now()

        err := db.QueryRow(query, t.Title, t.Description, t.Status, t.UserID, t.CreatedAt, t.UpdatedAt).Scan(&amp;t.ID)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error inserting task into database: %v", err) // Log the error
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (t *Task) UpdateTask(db database.DB) error <span class="cov8" title="1">{
        query := `
                UPDATE tasks
                SET title = $1, description = $2, status = $3, updated_at = $4
                WHERE id = $5`

        t.UpdatedAt = time.Now()

        _, err := db.Exec(query, t.Title, t.Description, t.Status, t.UpdatedAt, t.ID)
        return err
}</span>

func (t *Task) UpdateTaskPosition(db database.DB, userID int, newPosition int) error <span class="cov8" title="1">{
        tx, err := db.Begin()
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">defer tx.Rollback()

        // Get current position
        var oldPosition int
        err = tx.QueryRow(`
        SELECT position 
        FROM tasks 
        WHERE id = $1 AND user_id = $2`, t.ID, userID).Scan(&amp;oldPosition)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Update positions of other tasks
        <span class="cov8" title="1">if oldPosition &lt; newPosition </span><span class="cov8" title="1">{
                _, err = tx.Exec(`
            UPDATE tasks 
            SET position = position - 1,
                updated_at = $1
            WHERE user_id = $2 
            AND position &gt; $3 
            AND position &lt;= $4`,
                        time.Now(), userID, oldPosition, newPosition)
        }</span> else<span class="cov8" title="1"> {
                _, err = tx.Exec(`
            UPDATE tasks 
            SET position = position + 1,
                updated_at = $1
            WHERE user_id = $2 
            AND position &gt;= $3 
            AND position &lt; $4`,
                        time.Now(), userID, newPosition, oldPosition)
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Update position of the current task
        <span class="cov8" title="1">t.Position = newPosition
        t.UpdatedAt = time.Now()
        _, err = tx.Exec(`
        UPDATE tasks 
        SET position = $1,
            updated_at = $2
        WHERE id = $3 AND user_id = $4`,
                t.Position, t.UpdatedAt, t.ID, userID)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return tx.Commit()</span>
}

func (t *Task) ValidateStatus() error <span class="cov8" title="1">{
        for _, status := range ValidStatuses </span><span class="cov8" title="1">{
                if t.Status == status </span><span class="cov8" title="1">{
                        return nil
                }</span>
        }
        <span class="cov8" title="1">return fmt.Errorf("invalid status: %s", t.Status)</span>
}

func DeleteTask(db database.DB, id int) error <span class="cov8" title="1">{
        query := `DELETE FROM tasks WHERE id = $1`
        result, err := db.Exec(query, id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("task not found")
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package models

import (
        "fmt"
        "log"
        "strings"
        "time"

        "github.com/lib/pq"
        "github.com/maxzhirnov/go-task-manager/pkg/database"
        "golang.org/x/crypto/bcrypt"
)

type User struct {
        ID        int       `json:"id"`
        Username  string    `json:"username"`
        Password  string    `json:"password,omitempty"`
        CreatedAt time.Time `json:"created_at"`
        UpdatedAt time.Time `json:"updated_at"`
}

// HashPassword hashes the user's password
func (u *User) HashPassword() error <span class="cov8" title="1">{
        hashedPassword, err := bcrypt.GenerateFromPassword([]byte(u.Password), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">u.Password = string(hashedPassword) // Replace plaintext password with hash
        return nil</span>
}

// CheckPassword compares a plaintext password with the hashed password
func (u *User) CheckPassword(password string) error <span class="cov8" title="1">{
        log.Printf("Attempting to compare:")
        log.Printf("Stored hash: %s", u.Password)
        log.Printf("Input password: %s", password)

        if password == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("password cannot be empty")
        }</span>

        <span class="cov8" title="1">err := bcrypt.CompareHashAndPassword([]byte(u.Password), []byte(password))
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("Password comparison failed: %v", err)
        }</span>
        <span class="cov8" title="1">return err</span>
}

// CreateUser inserts a new user into the database
func (u *User) CreateUser(db database.DB) error <span class="cov8" title="1">{
        // Check if username or password is empty
        if u.Username == "" || u.Password == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("username and password are required")
        }</span>

        // Check if password is hashed
        <span class="cov8" title="1">if !strings.HasPrefix(u.Password, "$2a$") </span><span class="cov0" title="0">{
                return fmt.Errorf("password must be hashed before saving")
        }</span>

        <span class="cov8" title="1">log.Printf("Creating user with hash: %s", u.Password)

        query := `
        INSERT INTO users (username, password, created_at, updated_at)
        VALUES ($1, $2, $3, $4)
        RETURNING id`

        u.CreatedAt = time.Now()
        u.UpdatedAt = time.Now()

        log.Printf("Storing hashed password for user %s: %s", u.Username, u.Password)

        err := db.QueryRow(query, u.Username, u.Password, u.CreatedAt, u.UpdatedAt).Scan(&amp;u.ID)
        if err != nil </span><span class="cov8" title="1">{
                // Check if the error is due to a unique constraint violation
                if pqErr, ok := err.(*pq.Error); ok &amp;&amp; pqErr.Code == "23505" </span><span class="cov8" title="1">{ // Unique constraint violation
                        return fmt.Errorf("username already exists")
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// GetUserByUsername retrieves a user by their username
func GetUserByUsername(db database.DB, username string) (User, error) <span class="cov8" title="1">{
        var user User
        query := `SELECT id, username, password, created_at, updated_at FROM users WHERE username = $1`
        err := db.QueryRow(query, username).Scan(&amp;user.ID, &amp;user.Username, &amp;user.Password, &amp;user.CreatedAt, &amp;user.UpdatedAt)
        if err != nil </span><span class="cov8" title="1">{
                return user, err
        }</span>
        <span class="cov8" title="1">if user.Password == "" </span><span class="cov0" title="0">{
                return user, fmt.Errorf("invalid password hash")
        }</span>
        <span class="cov8" title="1">return user, nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package database

import (
        "database/sql"
        "fmt"
        "log"
        "os"
        "time"

        _ "github.com/lib/pq"
)

// DB is an interface that both *sql.DB and our mock can implement
type DB interface {
        Query(query string, args ...interface{}) (*sql.Rows, error)
        QueryRow(query string, args ...interface{}) *sql.Row
        Exec(query string, args ...interface{}) (sql.Result, error)
        Close() error
        Begin() (*sql.Tx, error)
}

func InitDB() (DB, error) <span class="cov0" title="0">{
        dbHost := os.Getenv("DB_HOST")
        if dbHost == "" </span><span class="cov0" title="0">{
                dbHost = "localhost"
        }</span>
        <span class="cov0" title="0">dbPort := os.Getenv("DB_PORT")
        if dbPort == "" </span><span class="cov0" title="0">{
                dbPort = "5432"
        }</span>
        <span class="cov0" title="0">dbUser := os.Getenv("DB_USER")
        if dbUser == "" </span><span class="cov0" title="0">{
                dbUser = "postgres"
        }</span>
        <span class="cov0" title="0">dbPassword := os.Getenv("DB_PASSWORD")
        if dbPassword == "" </span><span class="cov0" title="0">{
                dbPassword = "mysecretpassword"
        }</span>
        <span class="cov0" title="0">dbName := os.Getenv("DB_NAME")
        if dbName == "" </span><span class="cov0" title="0">{
                dbName = "taskmanager"
        }</span>

        <span class="cov0" title="0">connStr := fmt.Sprintf("host=%s port=%s user=%s password=%s dbname=%s sslmode=disable",
                dbHost, dbPort, dbUser, dbPassword, dbName)

        // Try to connect to the database with retries
        var db *sql.DB
        var err error
        maxRetries := 5
        for i := 0; i &lt; maxRetries; i++ </span><span class="cov0" title="0">{
                db, err = sql.Open("postgres", connStr)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to open database connection: %v", err)
                        time.Sleep(time.Second * 5)
                        continue</span>
                }

                <span class="cov0" title="0">err = db.Ping()
                if err == nil </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">log.Printf("Failed to ping database (attempt %d/%d): %v", i+1, maxRetries, err)
                time.Sleep(time.Second * 5)</span>
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to connect to database after %d attempts: %v", maxRetries, err)
        }</span>

        // Set connection pool settings
        <span class="cov0" title="0">db.SetMaxOpenConns(25)
        db.SetMaxIdleConns(25)
        db.SetConnMaxLifetime(5 * time.Minute)

        return db, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
